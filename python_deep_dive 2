break과 continue
[ ]
for i in range(10):
    print(i)
    if i == 5:
        break
0
1
2
3
4
5
[ ]
# 모든 for가 중단이 되는 것은 아닙니다!
# 자신을 감싸고 있는 단일 반복문만 탈출합니다.
for i in range(10):
    print('----------------')
    print(i)
    for j in range(10):
        print(i, j)
        if i == 5:
            break
----------------
0
0 0
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9
----------------
1
1 0
1 1
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
----------------
2
2 0
2 1
2 2
2 3
2 4
2 5
2 6
2 7
2 8
2 9
----------------
3
3 0
3 1
3 2
3 3
3 4
3 5
3 6
3 7
3 8
3 9
----------------
4
4 0
4 1
4 2
4 3
4 4
4 5
4 6
4 7
4 8
4 9
----------------
5
5 0
----------------
6
6 0
6 1
6 2
6 3
6 4
6 5
6 6
6 7
6 8
6 9
----------------
7
7 0
7 1
7 2
7 3
7 4
7 5
7 6
7 7
7 8
7 9
----------------
8
8 0
8 1
8 2
8 3
8 4
8 5
8 6
8 7
8 8
8 9
----------------
9
9 0
9 1
9 2
9 3
9 4
9 5
9 6
9 7
9 8
9 9
[ ]
# continue는 다음 루프로 갑니다.
# 아래 코드에서 continue는 의미가 없습니다.
for i in range(10):
    print(i)
    if i == 5:
        continue
0
1
2
3
4
5
6
7
8
9
[ ]
# continue는 다음 루프로 갑니다.
# 아래 코드에서 continue는 아래 print를 실행시키지 않고
# 다음 루프로 가게됩니다.
for i in range(10):
    if i == 5:
        continue
    print(i)
0
1
2
3
4
6
7
8
9
[ ]
for i in range(10):
    if i == 5:
        pass # 공백을 채워주는 역활만 합니다.
    print(i)
0
1
2
3
4
5
6
7
8
9
[ ]
for i in range(10):
    print(i)
    i += 2 # 작동이 되지 않습니다.
0
1
2
3
4
5
6
7
8
9
[ ]
for i in range(0, 10, 2):
    print(i)
0
2
4
6
8
[ ]
# 실행과 동시에 정지를 눌러주세요.
# 무한반복입니다.
# 아래 코드는 효율적이지 못하니
# 뒤에서 배울 generator로 무한반복을 구현해주세요.
l = [1]
for i in l:
    l.append(i+1)
    print(i)
for와 else 구문
[ ]
# 다른 언어에서는 이 구문이 작동되지 않습니다.
for i in range(10):
    if i == 5:
        break
else:
    print('정상종료!')
[ ]
# 반복문 + else구문은
# 반복문이 break을 쓰지 않고 정상 종료되었을 때
# else 구문이 실행됩니다.

for i in range(10):
    if i == 5:
        pass
else:
    print('정상종료!')
정상종료!
리스트 표현식(list comprehension)
[ ]
# 별 3.5개
# 리스트 안에 반복문이나 조건문을 넣어 한 번에 리스트를 생성하는 기법
# 리스트 표현식은 for보다 빠릅니다! (가독성 + 속도우위)
l = []
for i in range(10):
    l.append(i)
l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[ ]
[i for i in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[ ]
# 이정도만 하실 수 있으면 우리 수업에서는 문제 없습니다.
l = []
for i in range(10):
    if i % 2 == 0:
        l.append(i)
l
[0, 2, 4, 6, 8]
[ ]
[i for i in range(10) if i % 2 == 0]
[0, 2, 4, 6, 8]
[ ]
list(range(0, 10, 2)) # 이것도 가능하고, 직관적이죠.
[0, 2, 4, 6, 8]
[ ]
l = ['aa', 'abc', 'bbb', 'ccc', 'aba']
[i for i in l if 'a' in i]
['aa', 'abc', 'aba']
[ ]
# 아래 코드는 어떻게 할까요?
l = []
for i in range(10):
    if i % 2 == 0:
        l.append(i)
    elif i % 3 == 0:
        l.append(i)
l
[0, 2, 3, 4, 6, 8, 9]
[ ]
l = []
for i in range(10):
    if i % 2 == 0 or i % 3 == 0:
        l.append(i)
l
[0, 2, 3, 4, 6, 8, 9]
[ ]
[i for i in range(10) if i % 2 == 0 or i % 3 == 0]
[0, 2, 3, 4, 6, 8, 9]
[ ]
# [i for i in range(10) if i % 2 == 0 elif i % 3 == 0] # error
[ ]
# 구구단
# 손으로 꼭 순회 1번씩 돌아보셔야 합니다.
# for i in range(2, 10):
#     for j in range(1, 10):
#         print(i, j, i*j)

'''
# step 0
# 이렇게 손이나 문자열로 늘여트려놓고
# 내가 무엇을 줄일 수 있을까?를 고민하세요.
2 1 2
2 2 4
2 3 6
2 4 8
2 5 10
2 6 12
2 7 14
2 8 16
2 9 18
3 1 3
3 2 6
3 3 9
3 4 12
3 5 15
3 6 18
3 7 21
3 8 24
3 9 27
'''

# step 1 ~ 100 이렇게 하나씩 줄여가면 됩니다.
# for i in range(1, 10):
#     print(2, i, 99)

# step 1 ~ 100 이렇게 하나씩 줄여가면 됩니다.
# for i in range(1, 10):
#     print(2, i, 2*i)

for 단 in range(2, 10):
    for i in range(1, 10):
        print(단, i, 단*i)
[ ]
# 별찍기
# 트리 만드는 문제도 있고, 원 만드는 문제도 있고...
'''
*
**
***
****
*****
'''
[ ]
user_input = int(input('찍을 별의 층수?'))
for i in range(1, user_input+1):
    print('*' * i)
찍을 별의 층수?5
*
**
***
****
*****
[ ]
l = []
for i in range(2, 10):
    for j in range(1, 10):
        l.append([i, j, i*j])
l
[ ]
[[i, j, i*j] for i in range(2, 10) for j in range(1, 10)]
다중 리스트 순회
[ ]
skill = [
        ('고기잡이', 100),
        ('고기팔기', 120),
        ('낚시', 5),
        ('통발', 5),
        ('큰그물', 5)
]

for i, j in skill:
    print(i,j)
[ ]
skill_name = ['고기잡이', '고기팔기', '낚시']
skill_point = [100, 120, 5]

for i, j in zip(skill_name, skill_point):
    print(i,j)
[ ]
# 이정도 코드만 아셔도 실무하는 것에는 무리가 없습니다.
skill = [
        ('고기잡이', [1, 100]),
        ('고기팔기', [1, 100]),
        ('낚시', [2, 100]),
        ('통발', [2, 100]),
        ('큰그물', [2, 100])
]

for i, j in skill:
    print(i, j)
[ ]
skill = [
        ('고기잡이', [1, 100]),
        ('고기팔기', [1, 100]),
        ('낚시', [2, 100]),
        ('통발', [2, 100]),
        ('큰그물', [2, 100])
]

for i, [x, y] in skill:
    print(i, x, y)
고기잡이 1 100
고기팔기 1 100
낚시 2 100
통발 2 100
큰그물 2 100
[ ]
skill = [
        ('고기잡이', (1, 100)),
        ('고기팔기', (1, 100)),
        ('낚시', (2, 100)),
        ('통발', (2, 100)),
        ('큰그물', (2, 100))
]

for i, [x, y] in skill:
    print(i, x, y)
고기잡이 1 100
고기팔기 1 100
낚시 2 100
통발 2 100
큰그물 2 100
[ ]
skill = [
        ('고기잡이', 'ab'), # ('고기잡이', 'abcd') 이런 형태는 error
        ('고기팔기', 'cd'),
        ('낚시', 'aa'),
        ('통발', 'cc'),
        ('큰그물', 'dd')
]

for i, [x, y] in skill:
    print(i, x, y)
고기잡이 a b
고기팔기 c d
낚시 a a
통발 c c
큰그물 d d
[ ]
# 문제
# data는 다음과 같은 데이터가 있습니다.
# 각각 skill 이름, skill 제한 레벨, skill 포인트, skill 등급입니다.
# 아래와 같이 출력해주세요.
data = [
        ('고기잡이', (1, 100, 'S')),
        ('고기팔기', (1, 100, 'A')),
        ('낚시', (2, 100, 'A')),
        ('통발', (2, 100, 'B')),
        ('큰그물', (2, 100, 'S'))
]

# 출력값
# 아래와 같은 형식으로 총 5개 출력해야 합니다.
# '축하합니다. S등급에 skill 고기잡이를 습득하셨습니다! 
#  해당 스킬은 레벨 제한 1에 스필 포인트 100입니다.'
[ ]
for name,(level_limit, point, rank) in data:
    print(f'축하합니다. {rank}등급의 skill {name}을(를) 습득하셨습니다!')
    print(f'해당 스킬은 레벨 제한 {level_limit}에 스킬 포인트 {point}입니다.')
축하합니다. S등급의 skill 고기잡이을(를) 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100입니다.
축하합니다. A등급의 skill 고기팔기을(를) 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100입니다.
축하합니다. A등급의 skill 낚시을(를) 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100입니다.
축하합니다. B등급의 skill 통발을(를) 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100입니다.
축하합니다. S등급의 skill 큰그물을(를) 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100입니다.
[ ]
for idx, (name, (level, point, rank)) in enumerate(data):
    print(f'축하합니다. {rank}등급의 skill {name}를 습득하셨습니다!\n해당 스킬은 레벨 제한 {level}에 스킬 포인트 {point} 입니다.')
축하합니다. S등급의 skill 고기잡이를 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100 입니다.
축하합니다. A등급의 skill 고기팔기를 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100 입니다.
축하합니다. A등급의 skill 낚시를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
축하합니다. B등급의 skill 통발를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
축하합니다. S등급의 skill 큰그물를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
[ ]
# 이 풀이가 좋습니다.
for name, (level, point, rank) in data:
    print(f'축하합니다. {rank}등급의 skill {name}를 습득하셨습니다!\n해당 스킬은 레벨 제한 {level}에 스킬 포인트 {point} 입니다.')
축하합니다. S등급의 skill 고기잡이를 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100 입니다.
축하합니다. A등급의 skill 고기팔기를 습득하셨습니다!
해당 스킬은 레벨 제한 1에 스킬 포인트 100 입니다.
축하합니다. A등급의 skill 낚시를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
축하합니다. B등급의 skill 통발를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
축하합니다. S등급의 skill 큰그물를 습득하셨습니다!
해당 스킬은 레벨 제한 2에 스킬 포인트 100 입니다.
while
[ ]
# 반복문 : for, while
a = 1
while a < 10: # True인 동안에
    print(a)
    a += 1
1
2
3
4
5
6
7
8
9
[ ]
# while 특정요소:
#     특정요소 값 꺼내는 문법
#     특정요소가 모두 없어질 때까지

l = [1, 2, 3]
while l: # []
    print(l.pop())
3
2
1
[ ]
l = {1, 2, 3}
while l: 
    print(l.pop())
1
2
3
[ ]
# 중복되는 문자열 중 가장 첫번째 나온
# 문자의 index를 반환하라!
s = 'abkkkbnbbbccdennnnneefefg'
ss = set(s)
while ss:
    string = ss.pop()
    print(string, s.index(string))
c 10
d 12
f 21
b 1
a 0
k 2
e 13
n 6
g 24
[ ]
# 이러한 무한반복은 메모리를 모두 소진합니다.
# 서버가 뻗을 수도 있습니다.
while True:
    user_input = input('$')
    split_data = user_input.split(' ')
    if split_data[0] == 'mkdir':
        print(f'{split_data[1]} 폴더가 생성되었습니다!')
    elif split_data[0] == 'rmdir':
        print(f'{split_data[1]} 폴더가 삭제되었습니다!')
    elif split_data[0] == 'exit':
        print('프로그램을 종료합니다.')
        break
$exit
프로그램을 종료합니다.
[ ]
import random

random.randint(1, 100)
14
[ ]
import random
# up down game

result = random.randint(1, 100)

while True:
    user_input = int(input())
    if user_input > result:
        print('down')
    elif user_input < result:
        print('up')
    else:
        print('맞췄습니다!')
        print('프로그램을 종료합니다.')
        break
50
down
25
down
12
down
9
맞췄습니다!
프로그램을 종료합니다.
[ ]
# 구구단이 출력되지 않는 코드
# 한땀한땀 따라가면서 왜 출력이 되지 않는지 체크해보세요.
x = 2
y = 1
while x < 10:
    while y < 10:
        print(x, y, x * y)
        y += 1
    x += 1
2 1 2
2 2 4
2 3 6
2 4 8
2 5 10
2 6 12
2 7 14
2 8 16
2 9 18
[ ]
# 구구단이 출력되지 않는 코드
# 한땀한땀 따라가면서 왜 출력이 되지 않는지 체크해보세요.
x = 2
y = 1
while x < 10:
    while y < 10:
        print(x, y, x * y)
        y += 1
    y = 1 # 초기화를 해주어야 다음 while에서 y < 10에 들어갈 수 있습니다.
    x += 1
[ ]
count = 0
while True:
    print(count)
    if count == 5:
        break
    count += 1
print('end')
0
1
2
3
4
5
end
[ ]
# 무한루프
count = 0.0
while True:
    print(count)
    if count == 0.3: #부동소수점 문제가 발생할 수 있습니다.
        break
    count += 0.1
print('end')
[ ]
# 0.30000000000000004
count = 0.0
while True:
    print(count)
    if count >= 0.3:
        break
    count += 0.1
print('end')
0.0
0.1
0.2
0.30000000000000004
end
[ ]
# 다른 언어에서는 이 구문이 작동되지 않습니다.
i = 0
while i < 10:
    if i == 5:
        break
    i += 1
else:
    print('정상종료!')
[ ]
i = 0
while i < 10:
    i += 1
else:
    print('정상종료!')
정상종료!
https://school.programmers.co.kr/learn/courses/30/lessons/120871
[ ]
# step1
count10 = 0
n = 15
while count10 < n + 1:
    print(count10)
    count10 += 1
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
[ ]
# step2 조건만 간단히 구현
count10 = 0
count3 = 0 # 3x 마을에서 쓰는 숫자
n = 5
while count10 < n + 1:
    count10 += 1
    count3 += 1
    if count3 % 3 == 0 or '3' in str(count3):
        count3 += 1
    # 저주의 숫자를 지나가도 다시 저주의 숫자일수 있습니다
    # 체크를 계속해야하는데 한 번만 합니다
    print(count10, count3)

count3
1 1
2 2
3 4
4 5
5 7
6 8
8
[ ]
# step3 조건만 간단히 구현 => 조건이 계속 반복되도록
count10 = 0
count3 = 0 # 3x 마을에서 쓰는 숫자
n = 10
while count10 < n:
    count10 += 1
    count3 += 1
    while count3 % 3 == 0 or '3' in str(count3):
        count3 += 1
    # 저주의 숫자를 지나가도 다시 저주의 숫자일수 있습니다
    # 체크를 계속해야하는데 한 번만 합니다
    print(count10, count3)
1 1
2 2
3 4
4 5
5 7
6 8
7 10
8 11
9 14
10 16
[ ]
# step3 조건만 간단히 구현 => 조건이 계속 반복되도록
count10 = 0
count3 = 0 # 3x 마을에서 쓰는 숫자
n = 10
while count10 < n:
    count10 += 1
    count3 += 1
    while count3 % 3 == 0 or '3' in str(count3):
        count3 += 1
    print(count10, count3)
[ ]
def solution(n):
    count10 = 0
    count3 = 0
    while count10 < n:
        count10 += 1
        count3 += 1
        while count3 % 3 == 0 or '3' in str(count3):
            count3 += 1
    return count3
[ ]
[i for i in range(1, 31) if i % 3 != 0 and not('3' in str(i))][n-1]
[1, 2, 4, 5, 7, 8, 10, 11, 14, 16, 17, 19, 20, 22, 25, 26, 28, 29]
[ ]
def solution(n):
    return [i for i in range(1, 1001) if i % 3 != 0 and not('3' in str(i))][n-1]
예외처리(try, except, else)
[ ]
# try:
#   실행문
# except:
#   예외 발생 시 처리문
# else:
#   예외 발생하지 않을 경우 실행문
[ ]
try:
    i = 1
    j = 0
    x = i/j
except:
    print("error")
else:
    print(x)
1.0
실제 데이터를 가지고 연습 (json gen)
[ ]
data = [
  {
    "_id": "6459c9f4ebc9d86c2a656d5e",
    "index": 0,
    "age": 27,
    "name": "Burgess Hammond",
    "gender": "male"
  },
  {
    "_id": "6459c9f4d99872fea5ad0459",
    "index": 1,
    "age": 38,
    "name": "Leon Luna",
    "gender": "male"
  },
  {
    "_id": "6459c9f4234b6e3701033326",
    "index": 2,
    "age": 35,
    "name": "Huber Nieves",
    "gender": "male"
  }
]

# 반복문을 사용해도 좋지만,
# 반복문을 사용하실 수 없다면 index로만 계산하셔도 좋습니다.
data[0]
data[0]['age']
data[0]['gender']
100
[ ]
#Lv0
(data[0]['age'] + data[1]['age'] + data[2]['age']) / 3

성별 = []
성별.append(data[0]['gender'])
성별.append(data[1]['gender'])
성별.append(data[2]['gender'])
print(성별)
print(성별.count('male') / len(data) * 100)
print(성별.count('female') / len(data) * 100)
0.0
[ ]
#Lv1
age_sum = 0
for i in range(3): # 좋은 코드는 아닙니다.
    age_sum += data[i]['age']
age_sum / 3

성별 = []
for i in range(3):
    성별.append(data[i]['gender'])
print(성별.count('male') / len(data) * 100)
print(성별.count('female') / len(data) * 100)
100.0
0.0
[ ]
#Lv1
age_sum = 0
for i in range(len(data)):
    age_sum += data[i]['age']
age_sum / 3

성별 = []
for i in range(len(data)):
    성별.append(data[i]['gender'])
print(성별.count('male') / len(data) * 100)
print(성별.count('female') / len(data) * 100)
[ ]
#Lv2

# 평균 (1줄)
# list(map(lambda x:x['age'], data))
sum(map(lambda x:x['age'], data)) / len(data)

# 성별 (1줄)
len(list(filter(lambda x:x['gender'] == 'male', data))) / len(data) * 100
len(list(filter(lambda x:x['gender'] == 'female', data))) / len(data) * 100
0.0
[ ]
# Q1
# sol1
sum([elem['age'] for elem in data]) / len(data)

# sol2
sum(map(lambda x:x['age'], data)) / len(data)

# Q2
gender = [elem['gender'] for elem in data]
male = gender.count('male')
female = gender.count('female')
print(f'{male/len(gender)*100:.2f} : {female/len(gender)*100:.2f}')
100
[ ]
# Q1
# sol1
sum([elem['age'] for elem in data]) / len(data)

# sol2
sum(map(lambda x:x['age'], data)) / len(data)

# Q2
gender = [elem['gender'] for elem in data]
male = gender.count('male')
female = gender.count('female')
malepercentage = male/len(gender)*100
femalepercentage = female/len(gender)*100
print(f'{malepercentage:.2f} : {femalepercentage:.2f}')
[ ]
# solve1
average_age = sum(map(lambda x: x['age'], data))/len(data)
male = len(list(filter(lambda x: x['gender'] == 'male', data)))
female = len(list(filter(lambda x: x['gender'] == 'female', data)))

print(f'평균나이는 {average_age} 입니다.\n성비는 남성 {male} : 여성 {female} 입니다.')

# solve2
average_age = sum(map(lambda x: x['age'], data))/len(data)
gender = list(map(lambda x : x['gender'], data))
gender_count = [gender.count('male'), gender.count('female')]
print(f'평균나이는 {average_age} 입니다.\n성비는 남성 {gender_count[0]} : 여성 {gender_count[1]} 입니다.')
알아야 하는 built-in function
수학적 통계에 활용되는 함수
abs( ) : 괄호 안에 있는 값을 절대값으로 출력해줍니다.
all( ) : 괄호 안에 있는 값들이 모두 True(False)일 때 True(False)를 출력합니다.
any( ) : 괄호안에 있는 값이 하나라고 True이면 True로 출력합니다.
pow( ) : 제곱을 출력합니다.
max( ) : 값의 최댓값을 출력합니다.
min( ) : 값의 최솟값을 출력합니다.
sum( ) : 값의 합계를 출력합니다.
len( ) : 문자열의 길이를 출력합니다.
sorted( ) : 데이터를 정렬해줍니다.
reversed( ) : 정렬되지 않은 상태에서 값을 역순으로 출력합니다.
[ ]
abs(-1)
all([True, True, True])
all([True, True, False])
all(['a', 'b', 'ccc'])
all(['a', '', 'ccc'])
if all([3 > 5, 12 % 2 == 0, 15 % 5 == 0]):
    print('hello')

if all([3 > 5, 
        12 % 2 == 0, 
        15 % 5 == 0]):
    print('hello')


if 3 > 5 and 12 % 2 == 0 and 15 % 5 == 0:
    print('hello')

# if all([one(), two(), three()]):
#     print('hello')

# all(True, True, True) # all() takes exactly one argument (3 given)

pow(2, 3) # 2 ** 3
8
[ ]
sum([[1, 2], [3, 4], [5, 6]], [])
sum([1, 2, 3, 4, 5], 100)
# sum([1, 2, 3, 4, 5], {1, 2, 3}) # error
[ ]
# __len__가 없는 것들 : map, zip, filter...
class str(str):
    def __len__(self):
        return 1000

len(str('hello world'))
1000
[ ]
# len(zip([1, 2, 3], 'abc')) # error
형변환 함수
set( )
dict( )
hex( ) : 16진법
bin( ) : 2진법
oct( ) : 8진법
bool( )
str( )
ord( ) : 각각의 문자에 대한 숫자값을 출력해줍니다.(유니코드표를 참고하세요.)
float( )
tuple( )
chr( ) : 숫자값을 통해서 문자를 출력합니다.
list( )
range( )
complex( )
[ ]
l = [1, 2, 3]
type(l)
list
[ ]
# 아래 3개는 int형
# bin( ) : 2진법
# oct( ) : 8진법
# hex( ) : 16진법
bin(7)
type(bin(7))
0b111
type(0b111)
int('111', 2)
int('0b111', 2)
# int(0b111, 2) #error
[ ]
chr(65)
ord('A')
65
[ ]
# list(range(start, stop, step))
list(range(0, 10, 2))
list(range(0, 10))
list(range(10))
list(range(-10, 10, 2))
list(range(0, -10, -2))
[0, -2, -4, -6, -8]
도움말
[ ]
def hojun():
    '''
    이호준이 작성한 함수
    '''
    pass

help(hojun)
Help on function hojun in module __main__:

hojun()
    이호준이 작성한 함수

object 관련 함수
dir( )
id( )
type( )
[ ]
# dir() # directory에 약자로 대상이 가진 attribute를 모두 출력합니다.
# attribute가 무엇인가? class에서 배울 멤버 + 메서드 입니다.
[ ]
def f():
    return 100

f.name = 'leehojun'
dir(f)
print(f.name)
leehojun
[ ]
# 배우는 재미
# 단시간에 될 수 없습니다. => 경쟁력
[ ]
l = 10
# 복사가 제대로 이뤄졌나?
id(l) # 깊은복사, 얕은복사
140662941172240
[ ]
type('abc') # str
print(type('abc')) # <class 'str'>
# print(type(f)) # class가 전체 Python을 관통하고 있습니다.
<class 'str'>
<class 'function'>
유용한 순회 가능 객체
enumerate( ) : 값에 순위를 매기고 싶을 때 사용합니다.
range( )
sorted( )
reversed( )
filter( )
zip( )
map( )
[ ]
print(type(range(3)))
<class 'range'>
[ ]
list(enumerate([10, 20, 30]))
[(0, 10), (1, 20), (2, 30)]
[ ]
list(enumerate([10, 20, 30], 100))
# list(enumerate([10, 20, 30], 'abc')) # error 뒤에 숫자를 입력해야 합니다.
[ ]
def 함수(x):
    return x > 15

list(filter(함수, [10, 20, 30, 40]))
list(filter(None, [True, True, False, False]))
# filter에 None 주는 것이 어디에 유용할까요?
# 여러가지 자료형이 섞여 있을 때 값이 들어있는 것만 찾을 경우
list(filter(None, [[], 'abc', '', ''])) 
['abc']
[ ]
list(zip('abc', 'defaaaa', 'ght', [1, 2, 3], [4, 5, 6, 7]))
[('a', 'd', 'g', 1, 4), ('b', 'e', 'h', 2, 5), ('c', 'f', 't', 3, 6)]
[ ]
x = [5, 4, 6, 8, 2]
list(zip('abcdefg', sorted(x)))
[('a', 2), ('b', 4), ('c', 5), ('d', 6), ('e', 8)]
[ ]
x = [5, 4, 6, 8, 2]
y = [7, 6, 45, 4, 2, 3, 3]
list(zip('abcdefg', zip(x, y)))
[('a', (5, 7)), ('b', (4, 6)), ('c', (6, 45)), ('d', (8, 4)), ('e', (2, 2))]
args, kargs
가변 아규먼트, 가변 키워드 아규먼트
[ ]
def print_args(a, *args): # 꼭 args가 될 필요는 없습니다.
    print(args)

print_args(100, True, 'leehojun')
(100, True, 'leehojun')
[ ]
def print_kwargs(a, **kwargs): # 꼭 kargs가 될 필요는 없습니다.
    print(a)
    print(kwargs)

print_kwargs(100, name='leehojun', age='10')
100
{'name': 'leehojun', 'age': '10'}
[ ]
def print_args(*args, b): # error입니다.
    print(args)

print_args(100, True, 'leehojun')
[ ]
def print_args(b, *args): # error입니다.
    print(args)

print_args(100, True, 'leehojun')
(True, 'leehojun')
[ ]
def print_args(b, *args): # error입니다. args 앞에 순서대로 넣을 변수가 있어야 합니다.
    print(args)

print_args(100, True, b='leehojun')
[ ]
one, two, *three = 1, 2, 3, 4, 5 # *가 하는 역활은? 남은 데이터의 패킹
print(one, two, three)
1 2 [3, 4, 5]
lambda
lambda 는 익명함수라고 하며, 이름이 없는 함수
[ ]
leehojun = lambda x : x**2

# def leehojun(x):
#     return x ** 2
[ ]
print(type(leehojun))
<class 'function'>
[ ]
print(type(lambda x : x**2))
<class 'function'>
[ ]
print(dir(lambda x : x**2))
['__annotations__', '__builtins__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
[ ]
def 함수(x):
    return x ** 2

print(dir(함수))
['__annotations__', '__builtins__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
[ ]
def add(x, y):
    return x + y
def sub():
    pass
def div():
    pass
def mul():
    pass

caculator = [add, sub, div, mul]
print(caculator[0](10, 20))#0번째 값은 add 입니다.

caculator2 = [lambda x,y:x+y, 
              lambda x,y:x-y, 
              lambda x,y:x/y, 
              lambda x,y:x*y]

print(caculator2[0](10, 20)) #0번째 값은 add 입니다.
print(caculator2[0](10, 20))
30
30
30
[ ]
def f():
    return lambda x,y:x+y

f()(10, 20)
30
[ ]
def f():
    return lambda x:lambda i:i**2

f()(1)(10)
100
[ ]
def f():
    return lambda x:lambda i:x*i**2

f()(2)(10)
200
lambda 실무 응용
lambda가 응용되는 곳 : map, filter, max, min, sorted
[ ]
# 실무에서도 많이 사용됩니다.
def 제곱(x):
    return x ** 2

# 재사용 하는 경우에는 함수로 선언하는 경우도 있습니다.
list(map(제곱, [1, 2, 3, 4]))
list(map(제곱, [1, 2, 3, 4]))

list(map(lambda x : x ** 2, [1, 2, 3, 4]))
[ ]
# 질문1 : 람다함수를 재귀로 사용할 수 있나요?
# 답 : Yes
fact = lambda x: 1 if x == 0 else x * fact(x-1)
fact(5)

# 질문2 : 클로저 함수에 대한 질문
# 답 : 클로저는 내일 나갑니다.
120
!! 오늘 배운 것 정리
반복문

정해진 순서를(next) 반복하는 것

형태

# for 변수 in 순회가능한객체: # stopItoration까지 반복
#     code

# while 조건: # true까지 반복
#     code 
순회 가능한 객체(이터러블 객체) : 문자열, 리스트, 튜플, 딕셔너리, 셋, range, enumerate, map, set, sorted, reverse 등

순회 불가능한 객체 : int, float 등

code 안에서 변수를 사용하지 않을 경우 언더바를 관습적으로 사용합니다.

# for _ in 순회가능한객체:
#     code
반복문 다음 else 구문 : break 없이 정상 종료 되면 실행

반복문 안에 break 구문 : 자신을 감싸고 있는 반복문 1개 탈출

반복문 안에 continue 구문 : 다음 루프로 넘어감

반복문 안에 pass : 공백만 채워줄 뿐 아무 기능 없음

bulit-in function

수학적 통계에 활용되는 함수

abs( ) : 괄호 안에 있는 값을 절대값으로 출력해줍니다.
all( ) : 괄호 안에 있는 값들이 모두 True(False)일 때 True(False)를 출력합니다.
any( ) : 괄호안에 있는 값이 하나라고 True이면 True로 출력합니다.
pow( ) : 제곱을 출력합니다.
max( ) : 값의 최댓값을 출력합니다.
min( ) : 값의 최솟값을 출력합니다.
sum( ) : 값의 합계를 출력합니다.
len( ) : 문자열의 길이를 출력합니다.
sorted( ) : 데이터를 정렬해줍니다.
reversed( ) : 정렬되지 않은 상태에서 값을 역순으로 출력합니다.
형변환 함수

set( )
dict( )
hex( ) : 16진법
bin( ) : 2진법
oct( ) : 8진법
bool( )
str( )
ord( ) : 각각의 문자에 대한 숫자값을 출력해줍니다.(유니코드표를 참고하세요.)
float( )
tuple( )
chr( ) : 숫자값을 통해서 문자를 출력합니다.
list( )
range( )
complex( )
도움말

help( )
object 관련 함수

dir( )
id( )
type( )
순회 가능한 객체

enumerate( ) : 값에 순위를 매기고 싶을 때 사용합니다.
range( )
sorted( )
reversed( )
filter( )
zip( )
map( )
args, kargs

가변 아규먼트, 가변 키워드 아규먼트

def print_args(*args): # 꼭 args가 될 필요는 없습니다.
  print(args)

print_args(100, True, 'leehojun')

####

def print_kwargs(**kwargs): # 꼭 kargs가 될 필요는 없습니다.
print(kwargs)

print_kwargs(name='leehojun', age='10')
lambda

lambda 는 익명함수라고 하며, 이름이 없는 함수

보통은 다시 사용되지 않을 함수를 선언할 때 사용

leehojun = lambda x : x**2

# def leehojun(x):
#     return x ** 2

list(map(lambda x : x ** 2, [1, 2, 3, 4]))

클래스
클래스는 데이터(멤버)와 기능(메서드)을 가지고 있는 인스턴트 객체를 생성하기 위한 역할

우리가 배우고 있는 Python을 객체 지향 프로그래밍 언어

  현실                                코드
  차 ---------------------------> class Car()
  정수 -------------------------> class int()
  실수 -------------------------> class float()

  인간이 만들어 
  놓은 현실 세계에서의 
  정의 또는 약속 --------------> class

  1 + 1 = 2가 컴퓨터 입장에서는 10일 수도 있고
  'A' + 'A' = 'AA'가 아니라 컴퓨터 입장에서는 130일 수 있습니다.
[ ]
class CarFactory(object): # 첫 문자는 대문자로 합니다.
    max_speed = 300
    max_people = 5
    # 아래 self는 스스로를 가리키기에
    # self는 인스턴스를 가리킵니다.
    def move(self):
        print('차가 움직이고 있습니다.')
    def stop(self):
        print('차가 멈췄습니다.')

# 클래스로 바로 접근해서 무엇을 하는 것을 권고하지 않습니다.
# (제대로 알지 못하는 상태에서(인스턴스 변수, 클래스 변수))
print(CarFactory.max_speed)
k5 = CarFactory() # 붕어빵(인스턴스) = 붕어빵틀(클래스)
k3 = CarFactory() # 차(인스턴스) = 자동차공장(클래스)
300
[ ]
class CarFactory(object):
    max_speed = 300
    max_people = 5
    def move(self):
        print('차가 움직이고 있습니다.')
    def stop(self):
        print('차가 멈췄습니다.')

k5 = CarFactory()
k3 = CarFactory()
k5.move()
k3.move()
k5.stop()
k3.stop()
print(k5.max_speed)
300
차가 움직이고 있습니다.
차가 움직이고 있습니다.
차가 멈췄습니다.
차가 멈췄습니다.
300
[ ]
d = {'one':10, 'two':20}
# d.three = 30
d['three'] = 30
print(d['three'])
30
[ ]
def f():
    pass
f.one = 10
f.two = 20
f.three = 30
print(f.one)
10
[ ]
# 메서드 : 클래스 내에 함수
# 멤버 : 클래스 내에 변수
class CarFactory(object):
    max_speed = 300
    max_people = 5
    def __init__(self, userInputName): # 인스턴스가 만들어질 때 실행되는 메서드
        self.name = userInputName
    def move(self):
        print(self.name, '차가 움직이고 있습니다.')
    def stop(self):
        print(self.name, '차가 멈췄습니다.')

k5 = CarFactory('케이파이브')
k3 = CarFactory('케이쓰리')
k5.move()
k3.move()
k5.stop()
k3.stop()
print(k5.max_speed)
케이파이브 차가 움직이고 있습니다.
케이쓰리 차가 움직이고 있습니다.
케이파이브 차가 멈췄습니다.
케이쓰리 차가 멈췄습니다.
300
[ ]
k3.name
k3.max_speed
300
[ ]
print(type(k3))
print(dir(k3))
# 'max_people', 멤버
# 'max_speed', 멤버
# 'move', 메소드
# 'name', 멤버
# 'stop' 메소드
<class '__main__.CarFactory'>
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'max_people', 'max_speed', 'move', 'name', 'stop']
[ ]
l = [10, 20, 30]
print(type(l))
print(dir(l))
# 메소드
# 'append', 'clear', 'copy', 'count', 'extend', 
# 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'
<class 'list'>
['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
[ ]
class list(object):
    def __add__(self):
        pass
    def __class__(self):
        pass
    def __class_getitem__(self):
        pass
    def __eq__(self):
        pass
    def __ge__(self):
        pass 
    # ... 생략 ...
    def append(self):
        pass
    def clear(self):
        pass
    def copy(self):
        pass
    def count(self):
        pass
    def extend(self):
        pass
    def index(self):
        pass
    # ... 생략 ...
[ ]
# 클래스 변수
# 클래스 바로 하위에 자리하고 있으며
# 모든 인스턴스가 공유합니다.
class Car(object):
    # kinds가 인스턴스에 없기에 class변수로 접근
    # speed는 값을 = 로 할당했기에 인스턴스변수 생성
    kinds = []
    speed = 300
    def add_kinds(self, name):
        self.kinds.append(name)
    def change_speed(self, speed):
        self.speed = speed

k5 = Car()
k3 = Car()
k5.add_kinds('k5')
k3.add_kinds('k3')
k5.change_speed(500)
k3.change_speed(250)

print('k5.kinds:', k5.kinds)
print('k3.kinds:', k3.kinds)
print('k5.speed:', k5.speed)
print('k3.speed:', k3.speed)
k5.kinds: ['k5', 'k3']
k3.kinds: ['k5', 'k3']
k5.speed: 500
k3.speed: 250
[ ]
# 클래스 변수
# 클래스 바로 하위에 자리하고 있으며
# 모든 인스턴스가 공유합니다.
# 인스턴스 변수
# 인스턴스 영역 안에서만 사용하는 변수
class Car(object):
    # kinds가 인스턴스에 없기에 class변수로 접근
    # speed는 값을 = 로 할당했기에 인스턴스변수 생성
    kinds = []
    speed = 300
    def add_kinds(self, name):
        self.kinds.append(name) # self.kinds = [name]로 사용하면 인스턴스 변수가 됩니다.
    def change_speed(self, speed):
        self.speed = speed

k5 = Car()
k3 = Car()
k5.speed = 500
k3.speed # 클래스 변수는 값을 공유한다고 했는데?
300
[ ]
id()
[ ]
주인공 = ['licat', 10000]

class MobFactory(object):
    def __init__(self, 이름, 공격력, 체력, 마력, 크기_넓이, 크기_높이, 아이템확률, x, y):
        self.name = 이름
        self.power = 공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.dropRate = 아이템확률

    def attack(self):
        주인공[1] -= self.power
        print(f'{self.name}이 {self.power}데미지로 공격했습니다.')
        print(f'주인공의 체력이 {주인공[1]}가 되었습니다.')

슬라임 = MobFactory('슬라임', 1, 10, 10, 2, 2, 100, 1, 1)
오크 = MobFactory('오크', 10, 10, 10, 2, 2, 80, 1, 1)
고블린 = MobFactory('고블린', 100, 10, 10, 2, 2, 60, 1, 1)
드래곤 = MobFactory('드래곤', 1000, 10, 10, 2, 2, 40, 1, 1)
해골 = MobFactory('해골', 10000, 10, 10, 2, 2, 1, 1, 1)

슬라임.attack()
슬라임이 1데미지로 공격했습니다.
주인공의 체력이 9999가 되었습니다.
[ ]
주인공 = ['licat', 10000]

class MobFactory(object):
    def __init__(self, 이름, 공격력, 체력, 마력, 크기_넓이, 크기_높이, 아이템확률, x, y):
        self.name = 이름
        self.power = 공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.dropRate = 아이템확률

    def attack(self):
        주인공[1] -= self.power
        print(f'{self.name}이 {self.power}데미지로 공격했습니다.')
        print(f'주인공의 체력이 {주인공[1]}가 되었습니다.')


오크 = MobFactory('오크', 10, 10, 10, 2, 2, 80, 1, 1)
고블린 = MobFactory('고블린', 100, 10, 10, 2, 2, 60, 1, 1)
드래곤 = MobFactory('드래곤', 1000, 100000, 10, 2, 2, 40, 1, 1)
해골 = MobFactory('해골', 10000, 10, 10, 2, 2, 1, 1, 1)

슬라임.attack()
슬라임이 1데미지로 공격했습니다.
주인공의 체력이 9999가 되었습니다.
[ ]
주인공 = ['licat', 10000]

class MobFactory(object):
    def __init__(self, 이름, 공격력, 체력, 마력, 크기_넓이, 크기_높이, 아이템확률, x, y):
        self.name = 이름
        self.power = 공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.dropRate = 아이템확률

    def __add__(self, next):
        if self.name == '슬라임':
            return MobFactory(f'왕{self.name + next.name}', 
                              self.power + next.power, 
                              10, 10, 2, 2, 100, 1, 1)
        return None

    def attack(self):
        주인공[1] -= self.power
        print(f'{self.name}이 {self.power}데미지로 공격했습니다.')
        print(f'주인공의 체력이 {주인공[1]}가 되었습니다.')
    

슬라임 = 슬라임 = MobFactory('슬라임', 1, 10, 10, 2, 2, 100, 1, 1)
왕슬라임 = 슬라임 + 슬라임

왕슬라임.power
왕슬라임.name

[ ]
# 성철님 코드
class User(object):
    def __init__(self, 이름, 공격력, 체력, 마력, 크기_넓이, 크기_높이, 아이템확률, x, y):
        self.name = 이름
        self.power = 공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.dropRate = 아이템확률

    def 슬라임_attack(self):
        슬라임.hp -= self.power
        print(f'{self.name}이 {self.power}데미지로 공격했습니다.')
        print(f'몬스터의 체력이 {슬라임.hp}가 되었습니다.')

licat = User('licat', 5, 10000, 1000, 2, 2, 0, 2, 2)
licat.슬라임_attack()
mura = User('mura', 5, 10000, 1000, 2, 2, 0, 2, 2)
mura.슬라임_attack()
licat이 5데미지로 공격했습니다.
몬스터의 체력이 5가 되었습니다.
mura이 5데미지로 공격했습니다.
몬스터의 체력이 0가 되었습니다.
[ ]
# 개선 코드
class User(object):
    def __init__(self, 이름, 공격력, 체력, 마력, 크기_넓이, 크기_높이, 아이템확률, x, y):
        self.name = 이름
        self.power = 공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.dropRate = 아이템확률

    def attack(self, target):
        target.hp -= self.power
        print(f'{self.name}이 {self.power}데미지로 공격했습니다.')
        print(f'{target.name}의 체력이 {target.hp}가 되었습니다.')

licat = User('licat', 5, 10000, 1000, 2, 2, 0, 2, 2)
licat.attack(슬라임)
licat.attack(드래곤)
licat이 5데미지로 공격했습니다.
슬라임의 체력이 -5가 되었습니다.
licat이 5데미지로 공격했습니다.
드래곤의 체력이 99995가 되었습니다.
[ ]
# 준균님 코드
class Hero(object):
    def __init__(self, hero_info):
        self.info = hero_info
    def get_info(self):
        print(f"{self.info['name']}/위치 : {self.info['pos']}/체력 {self.info['hp']}/{self.info['max_hp']} / 레벨{self.info['level']}")

licat = Hero({
    'name' : 'licat',
    'pos' : [1,2],
    'max_hp' : 100,
    'hp' : 100,
    'level' : 1,
})

mura = Hero({
    'name' : 'mura',
    'pos' : [5,5],
    'max_hp' : 200,
    'hp' : 200,
    'level' : 5,
})

licat.get_info()
mura.get_info()
[ ]
# 질문? JAVA의 this와 self가 같은 개념인지?
# 답? JavaScript나 JAVA의 self와 개념이 비슷한데, 역시나 이렇게 대조를 해가면서 공부를 하면
# 오해의 여지가 생깁니다. 데이터 구조부터 다르긴 합니다.
[ ]
# 동섭님 코드
고블린 = ['Monster', 5000]
class PlayerSet(object):
    def __init__(self, 이름, 물리공격력, 마법공격력, 체력, 마력, 크기_넓이, 크기_높이, 위치_x축, 위치_y축):
        self.name = 이름
        self.hit_power = 물리공격력
        self.magic_power = 마법공격력
        self.hp = 체력
        self.mp = 마력
        self.width = 크기_넓이
        self.height = 크기_높이
        self.coordinate_x = 위치_x축
        self.coordinate_y = 위치_y축
    def attack(self):
        고블린[1] -= self.hit_power
        print(f'{self.name}이 {self.hit_power}데미지로 공격했습니다.')
        print(f'고블린의 체력이 {주인공[1]}이 되었습니다.')
    def magic(self):
        고블린[1] -= self.magic_power
        self.mp -= 5
        print(f'{self.name}이 {self.magic_power}데미지로 공격했습니다.')
        print(f'고블린의 체력이 {고블린[1]}이 되었습니다.')
        print(f'{self.name}의 마력이 {self.mp}이 되었습니다.')


라이캣 = PlayerSet('liecat', 100, 10, 2000, 500, 5, 5, 25, 10)
뮤라 = PlayerSet('mura', 5, 100, 2000,  1000, 3, 3, 30, 17)

라이캣.attack(), 뮤라.magic()
라이캣.magic(), 뮤라.attack()
[ ]
# 종수님 코드
class Character(object):
    def __init__(self, 이름, 직업, 외형):
        self.name = 이름
        self.characterClass = 직업
        self.characterModel = 외형
        self.x = 0
        self.y = 0
    
    def change_model(self, newCharacterModel):
        self.characterModel = newCharacterModel
        print(f'외형 변경 {self.characterModel} -> {newCharacterModel}')
    
    def move_left(self):
        self.x += 1
        print(f'현재 좌표 ({self.x}, {self.y})')
    
    def move_right(self):
        self.x -= 1
        print(f'현재 좌표 ({self.x}, {self.y})')

    def move_up(self):
        self.y += 1
        print(f'현재 좌표 ({self.x}, {self.y})')
    
    def move_down(self):
        self.y -= 1
        print(f'현재 좌표 ({self.x}, {self.y})')

licat = Character('licat', 직업=1, 외형=1)
mura = Character('mura', 2, 2)
[ ]
# 쉽고 중요한 예제!

class BlogFactory(object):
    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

게시글3 = BlogFactory(
        '오늘 강원의 날씨',
        '오늘 강원의 날씨는 참 좋네요! 블라블라',
        '10000',
        '범남궁',
        '2023/05/10',
    )
    
게시글1.title

[ ]
# 쉽고 중요한 예제!

class BlogFactory(object):
    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

게시글3 = BlogFactory(
        '오늘 강원의 날씨',
        '오늘 강원의 날씨는 참 좋네요! 블라블라',
        '10000',
        '범남궁',
        '2023/05/10',
    )

data = [게시글1, 게시글2, 게시글3]
for i in data:
    print(i.title)
오늘 제주의 날씨
오늘 부산의 날씨
오늘 강원의 날씨
[ ]
# 쉽고 중요한 예제!
# 이 코드는 가능하면 손으로 2 ~ 3번 써보시길 권해드립니다.

class BlogFactory(object):
    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

게시글3 = BlogFactory(
        '오늘 강원의 날씨',
        '오늘 강원의 날씨는 참 좋네요! 블라블라',
        '10000',
        '범남궁',
        '2023/05/10',
    )

data = [게시글1, 게시글2, 게시글3]
for i in data:
    if i.writer == '이호준':
        print(i.title)
        print(i.content)
        print(i.count)
        print(i.create_date)
오늘 제주의 날씨
오늘 제주의 날씨는 참 좋네요! 블라블라
0
2023/05/10
[ ]
data = [게시글1, 게시글2, 게시글3]
for i in data:
    print(i.title)
    print(i.content)
    print(i.writer)
    print(i.count)
    print(i.create_date)
[ ]
data = [게시글1, 게시글2, 게시글3]
for i in data:
    print(f'<h2>{i.title}</h2>')
    print(f'<p>{i.content}</p>')
    print(f'<p>{i.writer}</p>')
    print(f'<p>{i.count}</p>')
    print(f'<p>{i.create_date}</p>')
[ ]
# 클래스 변수로 글쓴이 찾기
[ ]
# 조금 난이도가 있는 예제이기 때문에
# 기억하지 않으셔도 됩니다.

class BlogFactory(object):
    dataset = []

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜
        self.dataset.append(self)

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

게시글3 = BlogFactory(
        '오늘 강원의 날씨',
        '오늘 강원의 날씨는 참 좋네요! 블라블라',
        '10000',
        '범남궁',
        '2023/05/10',
    )

for i in 게시글1.dataset:
    print(i.title)
오늘 제주의 날씨
오늘 부산의 날씨
오늘 강원의 날씨
[ ]
# x = 10
# y = 10
# x.__add__ = lambda self, next : str(self) + str(next) # error
[ ]
# python read only method create 가능한가?
[ ]
class BlogFactory(object):
    dataset = []

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜
        self.dataset.append(self)

    def __str__(self):
        return 'hello'

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

print(게시글1, 게시글2)
hello hello
[ ]
# 중요한 예제입니다.
class BlogFactory(object):
    dataset = []

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜
        self.dataset.append(self)

    def __str__(self):
        return self.title

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

print(게시글1)
print(게시글2)
오늘 제주의 날씨
오늘 부산의 날씨
[ ]
# 중요한 예제입니다.
class BlogFactory(object):
    dataset = []

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜
        self.dataset.append(self)

    def __str__(self):
        return f'제목 : {self.title}, 내용 : {self.content[:5]}, 글쓴이 : {self.writer}'

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )

print(게시글1)
print(게시글2)
제목 : 오늘 제주의 날씨, 내용 : 오늘 제주, 글쓴이 : 이호준
제목 : 오늘 부산의 날씨, 내용 : 오늘 부산, 글쓴이 : 김재현
[ ]
# 중요한 예제입니다.
class BlogFactory(object):
    dataset = []

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        self.title = 제목
        self.content = 내용
        self.count = 조회수
        self.writer = 글쓴이
        self.create_date = 생성날짜
        self.dataset.append(self)

    def __str__(self):
        return f'{len(self.dataset)}. 제목 : {self.title}, 내용 : {self.content[:5]}, 글쓴이 : {self.writer}'

게시글1 = BlogFactory(
        '오늘 제주의 날씨',
        '오늘 제주의 날씨는 참 좋네요! 블라블라',
        '0',
        '이호준',
        '2023/05/10',
    )
print(게시글1)

게시글2 = BlogFactory(
        '오늘 부산의 날씨',
        '오늘 부산의 날씨는 참 좋네요! 블라블라',
        '1000000',
        '김재현',
        '2023/05/10',
    )
print(게시글2)
1. 제목 : 오늘 제주의 날씨, 내용 : 오늘 제주, 글쓴이 : 이호준
2. 제목 : 오늘 부산의 날씨, 내용 : 오늘 부산, 글쓴이 : 김재현
!! 클래스 연습문제
[ ]
# 각각 class를 만들어주시고, instance를 2개 이상 넣어서
# 활용(출력, 수정 등) 해보세요.
# 15분씩 총 30분, 6분에 문제를 냈기 때문에 36분까지 실습해보겠습니다.
# 각 코드는 만들어서 쓰레드에 올려주세요.
# 중요한 코드이니 꼭 한 번 만들어보세요! :)
class UserInfo(object):
    pass

class BookInfo(object):
    pass
[ ]
# (advanced) 그리고 물건을 사면 물건의 값이 UserInfo를 건드려야 하겠죠. 
# 물건도 class로 구현해주시면 너무 좋은 예제가 될 것 같네요. 🙂

# (advanced) 실제 github의 유저 정보를 등을 이용해서도 만들어보세요.
# https://api.github.com/repos/paullabkorea/jupyternotebookblog/languages
# https://docs.github.com/ko/rest/repos/repos?apiVersion=2022-11-28#get-a-repository

[ ]
import hashlib

비밀번호 = hashlib.sha256()
비밀번호.update('helloworld!'.encode('utf-8'))
비밀번호.hexdigest() # 영화를 집어넣든, 음악을 집어넣든, 소설을 집어넣든, 암호를 집어넣든 모두 64자로 만듭니다.

[ ]
# 1번째 스탭
# 공개되는 정보, 공개되지 않는 정보
# 멤버(정적 수치, 문자열)와 메서드(기능)
class Product(object):
    def __init__(self, 품명, 가격):
        self.product_name = 품명
        self.price = 가격
        
자전거 = Product(
    '자전거',
    100000,
)

class UserInfo(object):
    def __init__(self, 
                 이름, 
                 이메일,
                 비밀번호, 
                 주요접속기기, 
                 주요접속국가, 
                 주요접속지역, 
                 마지막접속일자, 
                 회원가입날짜, 
                 별명, 
                 적립금, 
                 생일, 
                 휴대폰번호, 
                 휴대폰인증여부, 
                 고객등급, 
                 휴면계정여부):
        self.이름 = 이름
        self.고객등급 = 고객등급
        self.적립금 = 적립금
    
    def 물품구매(self, product):
        self.적립금 -= product.price

    def 회원탈퇴(self):
        pass

    def 장바구니등록(self):
        pass

이호준 = UserInfo(
    이름 = '이호준',
    이메일 = 'hojun@gmail.com',
    비밀번호 = '98d234db7e91f5ba026a25d0d6f17bc5ee0a347ea2216b0c9de06d43536d49f4',
    주요접속기기 = 'Android',
    주요접속국가 = 'Korea',
    주요접속지역 = 'Jeju',
    마지막접속일자 = '23/05/10',
    회원가입날짜 = '23/05/10',
    별명 = '준',
    적립금 = 1000000000,
    생일 = '13/13',
    휴대폰번호 = '010-0000-0000',
    휴대폰인증여부 = True,
    고객등급 = 'VIP',
    휴면계정여부 = False,
)

이호준.물품구매(자전거)
이호준.적립금
999900000
[ ]
# 광호님 코드
class BookInfo(object):
    def __init__(self, title, price, writer, publisher, count, soldout, buyer):
        self.title = title
        self.price = price
        self.writer = writer
        self.publisher = publisher
        self.count = count
        self.soldout = soldout
        self.buyer = buyer

    def __str__(self):
        return self.title

    def sell(self, buyer):
        if self.get_soldout():
            print('재고가 없습니다')
            return None
        
        self.count -= 1
        self.add_buyer(buyer)
        
        if self.count <= 0:
           self.set_soldout(True)

    def add_buyer(self, buyer):
        self.buyer.append(buyer)
    
    def set_soldout(self, value):
        self.soldout = value

    def get_soldout(self):
        return self.soldout
[ ]
# 진찬님 코드
class BookInfo(object):
    dataset = []

    def __init__(self, title, writer, publisher, publish_date, price):
        self.title = title
        self.writer = writer
        self.publisher = publisher
        self.publish_date = publish_date
        self.price = price
        self.dataset.append(self)

    def __str__(self):
        return f'제목: {self.title}, 저자: {self.writer}, 출판사: {self.publisher}, 출판일: {self.publish_date}, 가격: {self.price}'
    
book1 = BookInfo(
    title = '마블',
    writer = '아이언맨',
    publisher = '어벤져스',
    publish_date = '2023/05/10',
    price = 10000
)
print(book1)
제목: 마블, 저자: 아이언맨, 출판사: 어벤져스, 출판일: 2023/05/10, 가격: 10000
[ ]
class Car(object):
    MaxSpeed = 300
    MaxPeoeple = 5
    def __init__(self):
        pass
    def move(self, x):
        pass
    def stop(self):
        print('멈췄습니다.')
    @staticmethod #decorator
    def 스피드배속(현재스피드, 배속할스피드):
        print(f'현재 {현재스피드 * 배속할스피드}의 스피드로 달리고 있습니다.')

Car.스피드배속(100, 2) # 붕어빵 찍는 틀이 얼마나 붕어빵을 만들어 냈는가?
현재 200의 스피드로 달리고 있습니다.
[ ]
#예를 들어
class Hotel:
    pass

Hotel.빈방있는호텔() # 전체 호텔에 빈방이 있는 호텔
호텔1.빈방() #호텔1에 빈방이 있는지 여부
상속
[ ]
# 이 예제는 기억하고 있으셔야 합니다.
class Car:
    maxSpeed = 300
    maxPeople = 5
    def move(self, x):
        print(x, '의 스피드로 달리고 있습니다.')
    def stop(self):
        print('멈췄습니다.')

class HybridCar(Car):
    battery = 1000
    batteryKM = 300

class ElectricCar(HybridCar):
    battery = 2000
    batteryKM = 600
[ ]
dir(k3)

[ ]
K3 = Car()
HyK3 = HybridCar()
ElHyK3 = ElectricCar()
# id(K3.maxSpeed), id(HyK3.maxSpeed)
# id(K3.move), id(HyK3.move)

ElHyK3.move(10)
10 의 스피드로 달리고 있습니다.
!! 오늘 배운 것 정리
클래스

클래스는 데이터(멤버)와 기능(메서드)을 가지고 있는 인스턴트 객체를 생성하기 위한 역할

우리가 배우고 있는 Python을 객체 지향 프로그래밍 언어

  현실                                코드
  차 ---------------------------> class Car()
  정수 -------------------------> class int()
  실수 -------------------------> class float()

  인간이 만들어 
  놓은 현실 세계에서의 
  정의 또는 약속 --------------> class

  1 + 1 = 2가 컴퓨터 입장에서는 10일 수도 있고
  'A' + 'A' = 'AA'가 아니라 컴퓨터 입장에서는 130일 수 있습니다.
  현실세계에서 '인간끼리' 약속을 코드에 세계로 옮긴거에요.
예제 1

  # 메서드 : 클래스 내에 함수
  # 멤버 : 클래스 내에 변수
  # 애트리뷰트 : 멤버 + 메서드
  class CarFactory(object):
      max_speed = 300
      max_people = 5
      def move(self):
          print('차가 움직이고 있습니다.')
      def stop(self):
          print('차가 멈췄습니다.')

  k5 = CarFactory()
  k3 = CarFactory()
  k5.move()
  k3.move()
  k5.stop()
  k3.stop()
  print(k5.max_speed)
예제2

  # 클래스 변수
  # 클래스 바로 하위에 자리하고 있으며
  # 모든 인스턴스가 공유합니다.
  # 인스턴스 변수
  # 인스턴스 영역 안에서만 사용하는 변수
  class Car(object):
      # kinds가 인스턴스에 없기에 class변수로 접근
      # speed는 값을 = 로 할당했기에 인스턴스변수 생성
      kinds = []
      speed = 300
      def add_kinds(self, name):
          self.kinds.append(name) # self.kinds = [name]로 사용하면 인스턴스 변수가 됩니다.
      def change_speed(self, speed):
          self.speed = speed

  k5 = Car()
  k3 = Car()
  k5.speed = 500
  k3.speed # 클래스 변수는 값을 공유한다고 했는데?
예제3

  # 쉽고 중요한 예제!
  # 이 코드는 가능하면 손으로 2 ~ 3번 써보시길 권해드립니다.

  class BlogFactory(object):
      def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
          self.title = 제목
          self.content = 내용
          self.count = 조회수
          self.writer = 글쓴이
          self.create_date = 생성날짜

  게시글1 = BlogFactory(
          '오늘 제주의 날씨',
          '오늘 제주의 날씨는 참 좋네요! 블라블라',
          '0',
          '이호준',
          '2023/05/10',
      )

  게시글2 = BlogFactory(
          '오늘 부산의 날씨',
          '오늘 부산의 날씨는 참 좋네요! 블라블라',
          '1000000',
          '김재현',
          '2023/05/10',
      )

  게시글3 = BlogFactory(
          '오늘 강원의 날씨',
          '오늘 강원의 날씨는 참 좋네요! 블라블라',
          '10000',
          '범남궁',
          '2023/05/10',
      )

  data = [게시글1, 게시글2, 게시글3]
  for i in data:
      if i.writer == '이호준':
          print(i.title)
          print(i.content)
          print(i.count)
          print(i.create_date)
클래스 상속

클래스에서 상속은 상속해주는 클래스(Parent Class, Super class)의 내용(속성과 메소드)을 상속받는 클래스(Child class, sub class)가 가지게 되는 것

코드 예

  # 이 예제는 기억하고 있으셔야 합니다.
  class Car:
      maxSpeed = 300
      maxPeople = 5
      def move(self, x):
          print(x, '의 스피드로 달리고 있습니다.')
      def stop(self):
          print('멈췄습니다.')

  class HybridCar(Car):
      battery = 1000
      batteryKM = 300

  class ElectricCar(HybridCar):
      battery = 2000
      batteryKM = 600

  K3 = Car()
  HyK3 = HybridCar()
  ElHyK3 = ElectricCar()
  # id(K3.maxSpeed), id(HyK3.maxSpeed)
  # id(K3.move), id(HyK3.move)

  ElHyK3.move(10)
[ ]
# 질문 : id를 객체가 아니라 count라는 정수값을 지정해줘서 증가시키고 싶습니다.
# 답 : 아래코드처럼 사용하시면 됩니다.
class BlogFactory(object):

    count = 0

    def __init__(self, 제목, 내용, 조회수, 글쓴이, 생성날짜):
        BlogFactory.count += 1
        self.id = BlogFactory.count
        self.title = 제목

1. 제목 : 오늘 제주의 날씨, 내용 : 오늘 제주
2. 제목 : 오늘 부산의 날씨, 내용 : 오늘 부산
[ ]
# 자율학습시간에 대한 피드백 => 문제를 내드리기로 하였습니다.
# 매일 3시 40분 즈음에 advanced 문제를 드리고 각 조별 단톡방에 해당 내용을 공유하고 얘기하는 시간을 가지기로 하였습니다.
[ ]
print(chr(ord("生") & ord("死")))
愛

이터레이터
[ ]
class MyIter:
    def __init__(self, stop):
        self.currentValue = 0
        self.stop = stop
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.currentValue >= self.stop:
            raise StopIteration
        self.currentValue += 1
        return self.currentValue

li = MyIter(5)
for i in li:
    print(i)
1
2
3
4
5
[ ]
raise StopIteration
[ ]
class MyIter:
    def __init__(self, stop):
        self.currentValue = 0
        self.stop = stop
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.currentValue >= self.stop:
            raise StopIteration
        result = self.currentValue
        self.currentValue += 1
        return result

li = MyIter(5)
for i in li:
    print(i)

for i in li:
    print(i)
0
1
2
3
4
[ ]
class MyIter:
    def __init__(self, stop):
        self.stop = stop
    
    def __iter__(self):
        self.currentValue = 0
        return self

    def __next__(self):
        if self.currentValue >= self.stop:
            raise StopIteration
        result = self.currentValue
        self.currentValue += 1
        return result

li = MyIter(5)
# for는 iter먼저 실행하고, next로 StopIteration
for i in li:
    print(i)

for i in li:
    print(i)
0
1
2
3
4
0
1
2
3
4
[ ]
class MyIter:
    def __init__(self, stop):
        self.stop = stop
    
    def __iter__(self):
        self.currentValue = 0
        return self

    def __next__(self):
        if self.currentValue >= self.stop:
            raise StopIteration
        result = self.currentValue
        self.currentValue += 1
        return result

li = MyIter(5)
# for는 iter먼저 실행하고, next로 StopIteration
i = iter(li)
next(i)
0
[ ]
next(i)
[ ]
a, b, c, d = MyIter(4)
print(a, b, c, d)
0 1 2 3
[ ]
a, b, c, d = range(4)
print(a, b, c, d)
0 1 2 3
제너레이터
제너레이터란, 이터레이터를 생성해주는 함수
[ ]
def gen():
    count = 0
    while True:
        yield count
        count += 1


for i in gen():
    print(i)
    if i == 10:
        break
0
1
2
3
4
5
6
7
8
9
10
[ ]
def gen():
    count = 0
    while True:
        yield count
        count += 2

l = [10, 20, 30, 40, 50]
list(zip(l, gen()))
[(10, 0), (20, 2), (30, 4), (40, 6), (50, 8)]
[ ]
def gen():
    count = 0
    while True:
        yield f'{count}주차'
        count += 2
과목 = ['HTML', 'CSS', 'JavaScript', 'Python']

list(zip(과목, gen()))
[('HTML', '0주차'), ('CSS', '2주차'), ('JavaScript', '4주차'), ('Python', '6주차')]
[ ]
def gen():
    count = 1
    while True:
        yield count
        count += 1
        if count == 6:
            count = 1
과목 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']

list(zip(과목, gen()))
[('A', 1),
 ('B', 2),
 ('C', 3),
 ('D', 4),
 ('E', 5),
 ('F', 1),
 ('G', 2),
 ('H', 3),
 ('I', 4),
 ('J', 5),
 ('K', 1)]
데코레이터 (데커레이터)
[ ]
# 아래와 같이 실무에서 활용됩니다.

@login
def 비밀게시판():
    return render()

@check_vip
def vip용쿠폰():
    return render()

# 데이터 전처리 : 
# 데이터에 이상치(이상한 값), 결측치(비어있는 값) 등을 처리
# ['10', 1, 2, 3, '20'] -> [10, 1, 2, 3, 20]
@데이터전처리
sum(data)

@데이터전처리후페센테이지
sum(data)

# [10, 20, 30] -> 60%
[ ]
def one():
    return lambda x, y: x + y

더하기 = one()
더하기(10, 10)
20
[ ]
def one():
    def two(x, y):
        return x + y
    return two

더하기 = one()
더하기(10, 10)
20
[ ]
# 중요한 코드입니다.
# 손으로 2 ~ 3번 써보시길 권해드립니다.
def print_hello(func):
    def wrap_func():
        print('hello start')
        func()
        print('hello end')
    return wrap_func

@print_hello
def func1():
    print('func1 입니다.')

func1()
hello
func1 입니다.
[ ]
def 인사말(func):
    def wrap_func():
        print('안녕하세요.')
        func()
    return wrap_func

@인사말
def 자기소개1():
    print('이호준입니다.')

@인사말
def 자기소개2():
    print('홍길동입니다.')

def 작별인사():
    print('안녕히계세요.')

자기소개1()
자기소개2()
작별인사()
안녕하세요.
이호준입니다.
안녕하세요.
홍길동입니다.
안녕히계세요.
[ ]
def 인사말(func):
    def wrap_func():
        print('안녕하세요.')
        func()
    return wrap_func

def 자기소개1():
    print('이호준입니다.')

def 자기소개2():
    print('홍길동입니다.')

def 작별인사():
    print('안녕히계세요.')

인사말(자기소개1)()
인사말(자기소개2)()
작별인사()
안녕하세요.
이호준입니다.
안녕하세요.
홍길동입니다.
안녕히계세요.
[ ]
def 인사말(func):
    def wrap_func(이름):
        print('안녕하세요.')
        func(이름)
    return wrap_func

@인사말
def 자기소개1(name):
    print(f'{name}입니다.')

@인사말
def 자기소개2(name):
    print(f'{name}입니다.')

def 작별인사():
    print('안녕히계세요.')

자기소개1('이호준')
자기소개2('홍길동')
작별인사()
[ ]
def 인사말(func):
    def wrap_func(이름):
        print('안녕하세요.')
        func(이름)
    return wrap_func

def 자기소개1(name):
    print(f'{name}입니다.')

def 자기소개2(name):
    print(f'{name}입니다.')

def 작별인사():
    print('안녕히계세요.')

인사말(자기소개1)('이호준')
인사말(자기소개2)('홍길동')
작별인사()
안녕하세요.
이호준입니다.
안녕하세요.
홍길동입니다.
안녕히계세요.
[ ]
def 전처리(func):
    def wrap_func(iterable):
        iterable = list(map(int, iterable))
        print(func(iterable))
    return wrap_func

@전처리
def 평균(l):
    return sum(l) / len(l)

평균(['1', 2, 3, '4'])
2.5
[ ]
def 전처리(func):
    def wrap_func(iterable):
        return func(list(map(int, iterable)))
    return wrap_func

@전처리
def 평균(l):
    return sum(l) / len(l)

평균(['1', 2, 3, '4'])
2.5
[ ]
def 전처리(func):
    def wrap_func(iterable):
        i = list(map(int, iterable))
        calculate = func(i)
        result = str(calculate) + '%'
        return result
    return wrap_func

@전처리
def 평균(l):
    return sum(l) / len(l)

평균(['1', 2, 3, '4'])

[ ]
# 데코레이터 실습 문제
# 다음 값이 들어갔을 때, 숫자만 모두 더하는 코드를 완성하세요.
li = ['10', True, False, '21', 0, 10, 20]

@전처리
def custom_sum(l):
    sum(l)

custom_sum(li)
[ ]
# 코드리뷰는 여러분들과 분리하셔야 합니다.

# 승현님 코드
ls = ['10', True, False, '21', 0, 10, 20]

def 전처리(func):
    def wrap_func():
        return sum(filter(lambda x: isinstance(x, int), ls))
    return wrap_func

@전처리
def custom_sum():
    pass
    
custom_sum()
31
[ ]
# 준균님 코드
def 전처리(func):
    def wrap_func(iterable):
        print(func([int(i) for i in iterable if str(i).isdigit() == True]))
    return wrap_func

@전처리
def custom_sum(l):
    return sum(l)
    
custom_sum(['10', True, False, '21', 0, 10, 20])
61
[ ]
# 바름님 코드
l = ['10', True, False, '21', 0, 10, 20]

def 전처리(func):
    def warp_func(iterable):
        iterable = map(int, filter(lambda x: type(x) == int or type(x) == str, iterable))
        return func(iterable)
    return warp_func
    
@전처리
def custom_sum(data):
    return sum(data)

print(custom_sum(l))
61
[ ]
# 데코레이터에 argument를 넣는 방법
def deco1(name):
    def deco2(func):
        def wrapper():
            print('decorator1')
            func()
        return wrapper
    return deco2
 
# 데코레이터를 여러 개 지정
@deco1('hojun')
def hello():
    print('hello')
 
hello()
decorator1
hello
[ ]
# 2중 decorator
def decorator1(func):
    def wrapper():
        print(f'deco1 > wrapper > func : {id(func)}')
        func()
    print(f'deco1 > wrapper : {id(wrapper)}')
    return wrapper
 
def decorator2(func):
    def wrapper():
        print(f'deco2 > wrapper > func : {id(func)}')
        func()
    print(f'deco2 > wrapper : {id(wrapper)}')
    return wrapper
 
# 데코레이터를 여러 개 지정
@decorator1
@decorator2
def hello():
    print('hello')
 
hello()
deco2 > wrapper : 140658962986416
deco1 > wrapper : 140658962701552
deco1 > wrapper > func : 140658962986416
deco2 > wrapper > func : 140658962973744
hello
[ ]
id(decorator1), id(decorator2), id(hello)
(139922952125840, 139922952126272, 139922950549520)
모듈과 패키지
[ ]
# 연습1 (파일 1개 생성)
# 현재 폴더에 test1.py 파일을 생성했고
# name = 'leehojun'
# age = 10

# def hello():
#     pass

# class Human():
#     pass
[ ]
import test1

print(test1.name)
print(test1.hello())
leehojun
None
[ ]
# 연습 2 (파일 2개 생성)
# 주의!! 같은 이름이 있었을 경우
# 마지막에 추가된 추가된 변수명으로 할당
# import * 는 더더욱 포함시키는 변수, 메서드, 클래스 명을 알 수 없기에
# 주의해서 사용해야 합니다.
from test2 import name
from test1 import name

print(name)
leehojun1
[ ]
# 연습 3 (폴더 > 파일 생성)
# one이라는 것이 여기서는 폴더입니다!
# two가 file 이름이에요.
from one import two

print(two.name)
hello world
[ ]
# 연습 4 (폴더 > 폴더 > 파일 생성)
# 런타임 재시작 하세요!
from one.two import three

print(three.name)
hello world
[ ]
# 연습 5
import test1 as t

t.hello()
hello world
[ ]
# Python에 모듈
import pandas as pd
import numpy as np
[ ]
!mkdir leehojun
[ ]
!pip install 패키지이름
[ ]
!pip list # 실행 결과를 남겨드리고 싶으나 너무 길어 삭제
[ ]
import random as rd #랜덤한 숫자 반환

rd.randint(0, 10)
4
파일 입출력
[ ]
f = open('python.txt', 'w') # 파일모드 : r(read), w(write, 덮어씁니다.ㅜㅜ), a(append)
f.close()
[ ]
f = open('python.txt', 'w')
s = 'hello\nworld'
f.write(s)
f.close()
[ ]
# 문제 : 다음 입력을 통해 아래와 같은 출력 결과를 만드세요.
# (모듈 써수 푸셔도 좋지만 가능하면 모듈을 안쓰고 풀어보시길 권해드립니다.)
# 입력
data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]
# 출력
'''
{
    "one" : 10,
    "two" : 20,
    "three" : 30
}
'''
#코드
f = open('data.json', 'w')
s = str(dict(zip(data1,data2)))
f.write(s)
f.close()
[ ]
import json
# 입력
data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]
# 출력
'''
{
    "one" : 10,
    "two" : 20,
    "three" : 30
}
'''
#코드
f = open('data.json', 'w')
s = json.dumps(dict(zip(data1,data2)), indent=4)
f.write(s)
f.close()
[ ]
# 정답에 근접하였으나 콤마가 없고
# 띄어쓰기 4번이 안되어 있습니다.
data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]

'''
{
    "one" : 10,
    "two" : 20,
    "three" : 30
}
'''
f = open('data.json', 'w')
# 이 코드를 보면 다 덮어쓸 것 같지만 write할 때마다 append됩니다. w모드로 열어서도요.
f.write('{\n')
for elem in [f'"{d1}\" : {d2}' for d1, d2 in zip(data1, data2)]:
    f.write(elem)
    f.write('\n')
f.write('}')
f.close()
[ ]
# 바름님 코드 (정답!)
import json

data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]
'''
{
    "one" : 10,
    "two" : 20,
    "three" : 30
}
'''
f = open('data.json', 'w')
json.dump(dict(zip(data1,data2)),f,indent = '\t')
f.close()
[ ]
data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]

### https://stackoverflow.com/a/3229493
def pretty(d):
    ret = "{\n"
    for key, value in d.items():
        ret += '\t' + str(key).replace("'", "\"") + ": "
        ret += '\t' + str(value) + "\n"
    ret += "}"
    return ret

res = dict(zip(data1, data2))
stringed = str(res).replace("'", "\"")

# print(pretty(res))

f = open('data.json', 'w')
f.write(pretty(res))
f.close()
[ ]
import json
text = f'/////////////// 업데이트 방법 //////////////\n\
// 1. 아래 데이터는 민감데이터로 크롤링에 의존하지 않는 데이터입니다.\n\
//    긴급할 경우 아래 데이터만 수정하여 push 해주세요.\n\
// 2. 크롤러_통합.py를 실행시키시고, 모두 push해주시면 됩니다.\n\
//    크롤러_세계확진자.js, koreaRegionalData.js가 뽑힙니다.\n\
// 3. 크롤러가 동작하지 않을 경우 수동업데이트해야 합니다.\n\
////////////////////////////////////////////\n\
// 존스홉킨스 : https://gisanddata.maps.arcgis.com/a\n\
// https://www.worldometers.info/coronavirus/\n\
// 질본 : http://ncov.mohw.go.kr/bdBoardLis\n\
// 선차트용 데이터 - 제주도청 제공\n\
var 입도객현황 = '

data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]


f = open('data.js', 'w')
s = json.dumps(dict(zip(data1,data2)), indent=4)
s = text + s
f.write(s)
f.close()
[ ]
import json

text = f'안내문구\nvar 입도객현황 = '

data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]

f = open('data.js', 'w')
s = json.dumps(dict(zip(data1,data2)), indent=4)
s = text + s
f.write(s)
f.close()
[ ]
text = f'//안내문구\nvar 입도객현황 = '

data1 = ['one', 'two', 'three']
data2 = [10, 20, 30]

f = open('data.js', 'w')
s = str(dict(zip(data1,data2)))
s = text + s
f.write(s)
f.close()
[ ]
text = f'//안내문구\nvar 입도객현황 = '

data1 = ['one', 'two', 'three',]
data2 = [10, 20, 30,]

f = open('data.js', 'w')
s = str(data1)
s = text + s
f.write(s)
f.close()
[ ]
str(['one', 'two', 'three',])

파일 읽기
readline( ) : 라인 별로 읽습니다.
[ ]
f = open('python.txt', 'r')
while True:
    line = f.readline()
    if not line:
        break
    print(line)
f.close()
hello

world
readlines( ) : 전체 텍스트를 한꺼번에 읽어옵니다.
[ ]
f = open('python.txt', 'r')
lines = f.readlines()
for line in lines:
    print(line)
f.close()
read( ) : 파일 전체 내용을 읽어옵니다.
[ ]
f = open('python.txt', 'r')
data = f.read()
print(data)
f.close()
hello
world
[ ]
# 개행이 2번 되었던 이유는 print 함수가 이미 개행 옵션을 가지고 있기 때문
f = open('python.txt', 'r')
lines = f.readlines()
for line in lines:
    print(line, end='')
f.close()
hello
world
파일 입출력 심화 과정
github(https://github.com/paullabkorea/xlsxwriter) 에서 모든 소스코드를 다운로드 받으실 수 있습니다.
무료책인 인공지능을 활용한 업무자동화 책(2021 Version Notion)을 활용하면 좀 더 활용성이 극대화된 코딩이 가능합니다.(크롤링, 워드파일 크롤링, PDF크롤링, 문자 보내기 등)
업무자동화 Notion 링크 : https://paullabworkspace.notion.site/2021-6192ed4219fc4e7a96e10b22cfa27c80
[ ]
!pip3 install xlsxwriter
Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/
Collecting xlsxwriter
  Downloading XlsxWriter-3.1.0-py3-none-any.whl (152 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 152.7/152.7 kB 3.7 MB/s eta 0:00:00
Installing collected packages: xlsxwriter
Successfully installed xlsxwriter-3.1.0
[ ]
# openpyxl, xlrd, xlwt...
# 다른 사용자가 만든 모듈
[ ]
import xlsxwriter

# 엑셀 파일 생성하기
workbook = xlsxwriter.Workbook('test.xlsx')

# 파일 안에 워크 시트 생성하기
worksheet = workbook.add_worksheet('test')

data = ['AA', 'BB', 'CC', 'DD']
worksheet.write('A1', data[0])
worksheet.write('B1', data[1])
worksheet.write('C1', data[2])
worksheet.write('D1', data[3])

worksheet.write('A2', 1)
worksheet.write('B2', 2)
worksheet.write('C2', 3)
worksheet.write('D2', 4)
            #(행, 열, 데이터)
worksheet.write(2, 0, 10)
worksheet.write(2, 1, 20)
worksheet.write(2, 2, 30)
worksheet.write(2, 3, 40)

workbook.close()
[ ]
홍길동 = [33, 88, 24]
이호준 = [34, 66, 77]
김철수 = [78, 82, 36]
[ ]
홍길동 = [33, 88, 24]
이호준 = [34, 66, 77]
김철수 = [78, 82, 36]

workbook = xlsxwriter.Workbook('test.xlsx')
worksheet = workbook.add_worksheet('test')

l = ['이름', '국어', '영어', '수학', '평균']
for i in range(5):
    worksheet.write(0, i, l[i])

worksheet.write(1, 0, '홍길동')
for i in range(3):
    worksheet.write(1, i+1, 홍길동[i])
worksheet.write(1, 4, sum(홍길동) / len(홍길동))

worksheet.write(2, 0, '이호준')
for i in range(3):
    worksheet.write(2, i+1, 이호준[i])
worksheet.write(2, 4, sum(이호준) / len(이호준))

worksheet.write(3, 0, '김철수')
for i in range(3):
    worksheet.write(3, i+1, 김철수[i])
worksheet.write(3, 4, sum(김철수) / len(김철수))

workbook.close()
[ ]
홍길동 = [33, 88, 24]
이호준 = [34, 66, 77]
김철수 = [78, 82, 36]
all_data = [홍길동, 이호준, 김철수]

workbook = xlsxwriter.Workbook('test.xlsx')
worksheet = workbook.add_worksheet('Grades')

row_header = ['', '국어', '영어', '수학', '평균']
col_header = ['', '홍길동', '이호준', '김철수']

for idx, subject in enumerate(row_header):
    worksheet.write(0, idx, subject)

for idx, subject in enumerate(col_header):
    worksheet.write(idx, 0, subject)

for row_idx, line in enumerate(all_data):
    for col_idx, value in enumerate(line):
        worksheet.write(row_idx +1, col_idx + 1, value)
    # average
    avg = sum(line) / len(line)
    worksheet.write(row_idx + 1, len(line) + 1, avg)

workbook.close()
[ ]
import xlsxwriter

홍길동 = [33, 88, 24]
이호준 = [34, 66, 77]
김철수 = [78, 82, 36]

workbook = xlsxwriter.Workbook('test.xlsx')
worksheet = workbook.add_worksheet('test')

worksheet.write(0, 0, '이름')
worksheet.write(0, 1, '국어')
worksheet.write(0, 2, '영어')
worksheet.write(0, 3, '수학')

worksheet.write(1, 0, '홍길동')
worksheet.write(2, 0, '이호준')
worksheet.write(3, 0, '김철수')

for i in range(len(홍길동)):
    worksheet.write(1, i+1, 홍길동[i])
    worksheet.write(2, i+1, 이호준[i])
    worksheet.write(3, i+1, 김철수[i])

workbook.close()
[ ]
# 배보다 배꼽이 더 큰지 꼭 확인 하세요.
# 개발 시간 + 유지 보수
OS 모듈
[ ]
import os

os.getcwd() # os.getcwd() 함수는 현재 작업 디렉토리를 출력

[ ]
os.listdir() # 경로에 존재하는 파일과 디렉토리를 리스트로 반환할 때 사용
['.config',
 'leehojun',
 'test.xlsx',
 'python.txt',
 'test1.py',
 '__pycache__',
 'test2.py',
 'data.js',
 'data.json',
 '.ipynb_checkpoints',
 'one',
 'sample_data']
[ ]
for i in os.listdir():
    if len(i.split('.')) >= 2:
        if i.split('.')[1] == 'py' or i.split('.')[1] == 'txt':
            print(i)
python.txt
test1.py
test2.py
[ ]
os.mkdir('hello') # 폴더를 생성할 일이 없습니다. # log 누적할 때
[ ]
import glob

glob.glob("*.py")
['test1.py', 'test2.py']
advanced 문제
@writefile
def add(a, b):
    return a + b

# writefile의 데코레이터 기능은 아래와 같은 형식으로 result.txt에 항상 저장되게 하는 것입니다.
# {
#     "a": 10,
#     "b": 20,
#     "a+b": 30
# }
[ ]
# 동건님 코드 : 문제는 없으나 add를 실행시키긴 해야합니다!
# 데코레이터 => 아래 코드는 데코할 대상이 없는거에요.

'''
추가로 부연 설명을 합니다. :)
스토리로 굳이 표현하자면 아래와 같습니다.

1. add라는 함수를 내가 1년 전에 만들었다. 문제 없이 잘 작동하는 함수이다.
2. 이 add를 데코레이터를 써서 파일 입출력이 되게 하고 싶다.
3. 데코레이터를 만든다.
4. 기존의 코드도 정상적으로 작동이 되어야 한다.
'''

import json

def writerfile(func):
    def wrapper(a, b):
        data1 = ['a', 'b', 'a+b']
        data2 = [a, b, a+b]
        f = open('writerfile.json', 'w')
        json.dump(dict(zip(data1,data2)), f, indent = 4)
        f.close()
    return wrapper

@writerfile
def add(a,b):
    return a + b

add(10, 20)
[ ]
# 기존 코드
def add(a,b):
    return a + b

result = add(10, 20) + add(10, 20)
print(result)
[ ]
import json

def writerfile(func):
    def wrapper(a, b):
        data1 = ['a', 'b', 'a+b']
        data2 = [a, b, a+b]
        f = open('writerfile.json', 'w')
        json.dump(dict(zip(data1,data2)), f, indent = 4)
        f.close()
        return func(a, b)
    return wrapper

@writerfile
def add(a,b):
    return a + b

result = add(10, 20) + add(10, 20)
print(result)
60
!! 오늘 배운 것 정리
제너레이터

제너레이터란, 이터레이터(순회 가능한 객체)를 생성해주는 함수
예제 1
  def gen():
      count = 0
      while True:
          yield count
          count += 1
  for i in gen():
      print(i)
      if i == 10:
          break
데코레이터

함수 앞 뒤로 다른 역활을 해주는 기능을 붙이고 싶을 때 사용

코드 예

  def print_hello(func):
      def wrap_func():
          print('hello start')
          func()
          print('hello end')
      return wrap_func

  @print_hello
  def func1():
      print('func1 입니다.')

  func1()
파이썬 모듈

모듈 : 함수나 변수 또는 클래스를 모아 놓은 파이썬 파일

패키지 : 파이썬 모듈들을 계층적으로 관리

모듈 사용 예1

# 같은 폴더 내 test1.py
name = 'leehojun'
age = 10

def hello():
  pass

class Human():
  pass

# 같은 폴더 내 실행 파일
import test1

print(test1.name)
print(test1.hello())
예2

# 연습 3 (폴더 > 파일 생성)
# one이라는 것이 여기서는 폴더입니다!
# two가 file 이름이에요.
from one import two

print(two.name)
예3

# 연습 4 (폴더 > 폴더 > 파일 생성)
# 런타임 재시작 하세요!
from one.two import three

print(three.name)
파일 입출력

파일을 읽고 쓰는 것
파일 쓰기
f = open('python.txt', 'w') 
# 파일모드 : r(read), w(write, 처음부터 덮어씁니다.), a(append)
s = 'hello\nworld'
f.write(s)
f.close()
파일 읽기
f = open('python.txt', 'r')
while True:
  line = f.readline()
  if not line:
      break
  print(line)
f.close()
f = open('python.txt', 'r')
data = f.read()
print(data)
f.close()

Python Error
Python에서는 애러를 만나면 코드가(서비스가) 멈춥니다.
여러분들이 짠 코드가 서비스에 영향이 끼쳐지지 않도록 시니어 분들이 견고한 코드를 작성해놨을 겁니다.
TDD, 테스트 주도 개발 등 Test를 할 수 있는 환경 등이 갖춰져 있습니다.
작성한 코드는 실서비스로 바로 배포되지 않습니다. 작성한 코드는 테스트 서버로 일단 배포되서 잘 작동하는지 테스트 해봅니다.
[ ]
1 / 0

[ ]
for i in range(10)
    print(i)

[ ]
# Name Error
print(x)

[ ]
# Type Error
x = 10
y = '20'
print(x + y)

[ ]
# Index Error
my_list = [1, 2, 3]
print(my_list[3])

[ ]
# Key Error
my_dict = {'a': 1, 'b': 2}
print(my_dict['c'])

[ ]
# Value Error
int('a')

[ ]
# Attribute Error
my_list = [1, 2, 3]
print(my_list.appeend(4))

[ ]
# Type Error
def add(x, y):
    return x + y

add(1, 2, 3)

예외 처리
[ ]
try:
    # 예외가 발생할 가능성이 있는 코드
except:
    # 예외 처리 코드
[ ]
def div(a, b):
    return a / b

try:
    div(1, 0)
except:
    print('예외 발생')
예외 발생
[ ]
div(1, 0)

[ ]
def div(a, b):
    return a / b

def f():
    try:
        return div(1, 0)
    except:
        print('예외 발생')

result = f() + f() #result에는 float이 오길 기대하죠.
print(result)

[ ]
def div(a, b):
    return a / b

def f():
    try:
        return div(1, 0)
    except:
        return float('inf')

result = f() + f() #result에는 float이 오길 기대하죠.
print(result)
inf
[ ]
def div(a, b):
    return a / b

def f():
    try:
        return div(1, 0)
    except:
        return None

result = f() + f() #result에는 float이 오길 기대하죠.
print(result)

[ ]
def div(a, b):
    return a / b

def f():
    try:
        return div(1, 0)
    except:
        return 0

result = f() + f() #result에는 float이 오길 기대하죠.
print(result)
0
[ ]
try:
    # 예외가 발생할 가능성이 있는 코드
except:
    # 예외 처리 코드
else:
    # 예외가 발생하지 않을 때 실행되는 코드
[ ]
try:
    1/0
except:
    print('예외 발생!')
else:
    print('정상 종료!')
예외 발생!
[ ]
# while, for, try-except 구문에서 else는 언제 실행?
# 정상 정료 되었을 때
[ ]
try:
    10/2
except:
    print('예외 발생!')
else:
    print('정상 종료!')
정상 종료!
[ ]
# error가 나면 코드가 멈추기 때문에 보통 except와 함께 사용합니다.
try:
    # 예외가 발생할 가능성이 있는 코드
finally:
    # 예외 발생 여부와 상관없이 항상 실행되는 코드
[ ]
try:
    1/0
finally:
    print('finally')

print('hello world')

[ ]
try:
    # 예외가 발생할 가능성이 있는 코드
except:
    # 예외 처리 코드
finally:
    # 예외 발생 여부와 상관없이 항상 실행되는 코드
[ ]
try:
    1/0
except:
    print('hello')
finally:
    print('world')
hello
world
[ ]
try:
    # 예외가 발생할 가능성이 있는 코드
except:
    # 예외 처리 코드
else:
    # 예외가 발생하지 않을 때 실행되는 코드
finally:
    # 예외 발생 여부와 상관없이 항상 실행되는 코드
[ ]
try:
    1/0
except:
    print('except')
else:
    print('else')
finally:
    print('finally')
[ ]
try:
    10/2
except:
    print('except')
else:
    print('else')
finally:
    print('finally')
else
finally
[ ]
raise

[ ]
# raise 애러이름
raise ValueError

[ ]
raise LeeHoJun

[ ]
raise ValueError('코드를 잘~~ 만들어주세요.')

[ ]
try:
    1/0
except ValueError:
    print('ValueError')
except ZeroDivisionError:
    print('ZeroDivisionError')

print(ZeroDivisionError)
print(type(ZeroDivisionError))
print(dir(ZeroDivisionError))
ZeroDivisionError
<class 'ZeroDivisionError'>
<class 'type'>
['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']
[ ]
class Leehojun(Exception): #Exception을 상속받으면 됩니다.
    def __init__(self):
        super().__init__('입력된 값이 leehojun이 아닙니다.')

if 'leehojun' != input():
    raise Leehojun
else:
    print('leehojun이 맞습니다!')

[ ]
!pip list
[ ]
import sys

sys.path
['/content',
 '/env/python',
 '/usr/lib/python310.zip',
 '/usr/lib/python3.10',
 '/usr/lib/python3.10/lib-dynload',
 '',
 '/usr/local/lib/python3.10/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/local/lib/python3.10/dist-packages/IPython/extensions',
 '/root/.ipython']
[ ]
l = []
for i in [[10, 5], [20, 3], [30, 4], [40, 1]]:
    l.append(i[0] - i[1])
l
[5, 17, 26, 39]
[ ]
l = []
for i, j in [[10, 5], [20, 3], [30, 4], [40, 1]]:
    l.append(i - j)
l
[5, 17, 26, 39]
[ ]
l = [i - j for i, j in [[10, 5], [20, 3], [30, 4], [40, 1]]]
l
[5, 17, 26, 39]
[ ]
l = [[10, 5], [20, 3], [30, 4], [40, 1]]
map(lambda x: x[0]-x[1], l)
[ ]
s = 0
for i in '11123':
    s += int(i)
s
8
[ ]
[int(i) for i in '11123']
[1, 1, 1, 2, 3]
[ ]
sum([int(i) for i in '11123'])
8
[ ]
list(map(int, '11123'))
[1, 1, 1, 2, 3]
[ ]
sum(map(int, '11123'))
8
[ ]
list('11123')
['1', '1', '1', '2', '3']
[ ]
'!hello!wor     ld!     '.replace('!', '')

[ ]
'!hello!wor     ld!     '.replace('!', '').strip()

[ ]
'!hello!wor     ld!     '.replace('!', '').replace(' ', '')

클로저, 팩토리 함수
[ ]
def one():
    def two():
        return
    return two

hello = one() # hello == two
[ ]
def one(x):
    def two():
        return x + x
    return two

hello = one(10) # hello == two
hello() # hello() == two()
20
[ ]
def one(x):
    def two(a, b):
        return a + b + x
    return two

hello = one(10) # hello == two
hello(2, 3) # hello() == two()
[ ]
def user(username, usermoney):
    def userbuy(productname, productprice):
        leftmoney = usermoney - productprice
        return f'{productname}를 {username}님이 구매하셔서 계좌에 {leftmoney}가 남아있습니다.'
    return userbuy

이호준구매 = user('leehojun', 1000000)
이호준구매('자전거', 100000)

홍길동구매 = user('hongildong', 1000000)
홍길동구매('킥보드', 50000)

# 이호준구매와 홍길동구매 함수를 가지고 계좌를 조작할 수 있나요?
# 계좌 변수에 접근할 수 있나요?

[ ]
# S은행에 입사를 했습니다. 여러분들의 권한은 이호준구매 등에 구매함수만 조작할 수 있습니다
# 이렇게 되면 계좌 정보를 접근할 수가 없겠죠?
# 접근 통제, 제한, 변수 보호 등으로 사용합니다.
!! 오늘 배운 것 정리
애러처리

Python에서는 애러를 만나면 코드가(서비스가) 멈춥니다.
예제
  try:
      # 예외가 발생할 가능성이 있는 코드
  except:
      # 예외 처리 코드
  else:
      # 예외가 발생하지 않을 때 실행되는 코드
  finally:
      # 예외 발생 여부와 상관없이 항상 실행되는 코드
파일입출력

열기와 닫기를 동시에

with open('test.txt', 'w') as f:
  f.write('Life is too short, you need python')
파일에 추가

f = open('python.txt', 'a') # 다시 write 모드로 하면 처음부터 덮어 씁니다.
s = ''
for i in range(5, 11):
  s += f'{i}명 참여 중입니다. \n'
f.write(s)
f.close()
