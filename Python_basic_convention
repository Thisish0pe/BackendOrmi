## 깊은 복사와 얕은 복사

#아무런 복사도 이뤄지지 않은 상태
l=[[1,2,3],[4,5,6]]
ll=l
ll[0][0]=10
l,ll

#얕은 복사 
l=[1000,2000,3000,4000,5000,6000]
ll=l.copy()
ll[0]=10
l,ll

l=[1000,200,300,1000,1000,1000] #메모리를 아끼기 위해서 1000이 가리키는 메모리 값이 같은 것이다.

#얕은 복사 
l=[1000,2000,3000,4000,5000,6000]
ll=l.copy()
id(l[0]), id(ll[0]) #같은 값이 나오니깐 같은 객체를 가리키고 있다? 놉

#얕은 복사 
l=[[1,2,3],[4,5,6]]
ll=l.copy()
ll[0][0]=10
l,ll

id(l[0]), id(ll[0])

#얕은 복사 
l=[[1,2,3],[4,5,6]]
ll=l.copy()
ll[0]=100
l,ll

#list가 가르키는 뎁스와 0번째가 가르키는 뎁스는 다르다.

#얕은 복사는 한 덱스[]만 카피하고 깊은 복사는 다 카피한다

#깊은 복사
import copy

l=[[1,2,3],[4,5,6]]
ll=copy.deepcopy(l)
ll[0][0]=10
l,ll

id(l), id(ll)

id(l[0]), id(ll[0])
id(l[0][0]), id(ll[0][0])

l=[[1,2,[1, [999, 998]]],[4,5,[2, [333,332]]]]
ll=copy.deepcopy(l)
ll[0][2][1][0]=10
l, ll

* 얕은 복사는 1계층만 복사 합니다. []
* 깊은 복사는 n계층까지 모두 복사합니다.

#얕은복사
l=[[1,2,3],[4,5,6]]
ll=l[:]
l[0]=100
l,ll

#얕은복사
l=[[1,2,3],[4,5,6]]
ll=l[:] #l.copy써도 마찬가지
l[0][0]=100
l,ll

#얕은복사
#list comprehension 안 배운 내용이니 keep해두세요
#for문 배운다음 다시 오셔서 복습하시길 바랍니다.
l=[[1,2,3],[4,5,6]]
ll=[for i in l] #얕은복사
l[0][0]=100
l,ll

#1단계 깊은복사
#list comprehension 안 배운 내용이니 keep해두세요
#for문 배운다음 다시 오셔서 복습하시길 바랍니다.
l=[[1,2,3],[4,5,6]]
ll=[i[:] for i in l] #얕은복사
l[0][0]=100
l,ll

#다차원 리스트

# jun 만 뽑아주세요.
a = [[1, 2, 3],
     [11, 22, 33],
     ['leehojun', 20, 30]]

a[2][0][5:] #혹은[-3:]

# a=a[2]
# a=a[0]
# a=a[5:]
# a

##list 에서 built-in function을 활용

* 알아야하는 built-in function
```
A
abs()
all()
any()

B
bin()
bool()

C
chr()

D
dict()
dir()

E
enumerate()
eval()

F
filter()
float()

G
globals()

H
help()
hex()

I
id()
input()
int()
isinstance()
issubclass()
iter()

L
len()
list()
locals()

M
map()
max()
min()

N
next()

O
object()
oct()
open()
ord()

P
pow()
print()
property()

R
range()
repr()
reversed()
round()

S
set()
setattr()
slice()
sorted()
staticmethod()
str()
sum()
super()

T
tuple()
type()

V
vars()

Z
zip()
```

#built-in function: https://docs.python.org/3/library/functions.html



a = [1, 2, 3, 4, 5, 6, 7, 8]
print(max(a)) #최댓값
print(min(a)) #최솟값
print(sum(a)) #전체값의 합

#2차원
a = [[1, 2, 3],
     [11, 22, 33],
     [10, 2000, 30]]
max(a, key=lambda x:x[1])
min(a, key=lambda x:x[1])
# sum(a) error
sum(a, [])

a = [[1, 2, 3,'a'],
     [11, 22, 33,'aaa'],
     [10, 2000, 30,'aa']]
max(a, key=lambda x:x[1])
max(a, key=lambda x:len(x[3]))


호텔 = [['이스트소프트 호텔', 5, 100, 155000],
     ['삼스트소프트 호텔', 4, 80, 145000],
     ['사스트소프트 호텔', 3, 70, 135000],] #마지막 콤마를 허락하는 언어는 제한적입니다.

max(호텔, key=lambda x:x[3]) #가장 가격이 높은 것을 뽑아낼 수 있음 
min(호텔, key=lambda x:x[3])

## 리스트의 순회

#1차원
a = [1, 2, 3, 4, 5, 6, 7, 8]
# for 변수 in 순회가능한객체
for i in a: 
     print(i)

#2차원
a = [[1, 2, 3],
     [11, 22, 33],
     [13, 20000, 300000]]

for i in a:
    print(i)
    print('---')
print('end')

a = [[1, 2, 3],
     [11, 22, 33],
     [13, 20000, 300000]]

for i in a:
    for j in i:
        print(j)
        print('---')
print('end')

##range( )

# range(start , stop, step)
#슬라이싱과 같은 규칙
#슬라이싱은 : 로 연결, range는 ,(comma)로 연결.

print(list(range(100))) #python2.x 대에서 python3.x range 사용하고 싶을 때 xrange(10)사용
print(list(range(5, 10)))

print(list(range(0, 101, 2))) #짝수
print(list(range(1, 101, 2))) #홀수

print(sum(list(range(0, 101)))) #리소스 낭비이기 때문에
print(sum(range(0, 101))) #이렇게 해주세요

print(list(range(100, 1, -2)))

##list comprehension(리스트 표현식, 지능형 리스트)
- 간단한 리스트 생성할 때 많이 사용

# 1. list(range(1,101))
l=[]
for i in range(1,101):
    l.append(i)
l

# l=[]
# for i in range(1,11):
#     l.append(i**i)
# l

l=[i**i for i in range(1,11)]
l

l=[i for i in range(1,11)]
l

for i in range(1, 100):
    if i %3 == 0 or i %5 == 0:
        l.append(i)

[i for i in range(1, 100) if i %3 == 0 or i %5 == 0]

##튜플

- 튜플은 순서 (슬라이싱 인덱스 가능)가 있는 시퀀스형 자료형입니다.
- 참조값은 변경이 불가능(immutable) 합니다.
- 다른 자료형을 입력할 수 있으며, 튜플 안에 튜플로 다차원의 튜플을 만드는 것도 가능합니다.
- 값의 중복을 허락합니다.

l = [1, 2, 3]
t = (l, 20, 30) # 불변인 것은 t가 l을 참조하고 있다는 것
l[0] = 1000
t
# 해킹이 용이해지기 때문에 불변 안에는 불변만 넣자

type(t), dir(t)

t=(10,20,30,40,50)
t[:3]
#슬라이싱이 가능하다고 해서 가변이 아니다.

t=(10,20,30,40,50,20)
t.index(20), t.count(20)

t = tuple('leehojun')
t
t=tuple()
t
t = tuple(range(10))
t
t=(1) #튜플로 인지하지 못해요 인지하게 하려면
t=(1,)

##딕셔너리


- 딕셔너리는 순서가 없는 자료형입니다.
- 순서는 보장함 
- 사전형은 Key와 Value 가 하나의 묶음으로 이루어진 자료 체계입니다.
- 값의 변경이 가능합니다.
- 다른 자료형을 입력할 수 있습니다.
- 키의 중복은 허락하지 않고, 값의 중복을 허락합니다.

d = {'one' : '하나', 'two' : '둘', 'three' : '셋'}
d
d['one']


d['two']='투'
d

d = {} #dict
type(d)

d = {10} #set :문자 혹은 숫자가 들어가면 set
type(d)

d = dict() # dict
type:(d)

d = {'one':1} # dict : key와 value가 있으니깐
type:(d)

d = {'one' : '하나', 'two' : '둘', 'three' : '셋'}
d.items()

dict([('one', '하나'), ('two', '둘'), ('three', '셋')])

dict([['one', '하나'], ['two', '둘'], ['three', '셋']])

dict(name='leehojun', age=10)

list(zip('ABC', '123', 'abc'))

dict(zip('ABC', '123')) #형변환 / 맨마지막 abc를 넣어도 무시되는 결과를 볼 수 있음

#dic와 zip를 사용해서 아래와 같은 형태를 만들어주세요.

#원하는 형태 {}

dict(zip('ABC',[[10,20],[20,30],[30,40]]))

l=[10,20,30,40]
dic(zip('ABC', zip(l,l[1:])))


'B' in {'A': [10, 20], 'B': [20, 30], 'C': [30, 40]}

len({'A': [10, 20], 'B': [20, 30], 'C': [30, 40]})

def switch(day):
    return{
        1:'월요일',
        2:'화요일',
        3:'수요일',
        4:'목요일',
        5:'금요일',
        6:'토요일',
        7:'일요일',
    }[day]
print(switch(7))

def switch(day):
    return{
        1:'월요일',
        2:'화요일',
        3:'수요일',
        4:'목요일',
        5:'금요일',
        6:'토요일',
        7:'일요일',
    }.get(day)

switch(8)

def switch(day):
    return{
        1:'월요일',
        2:'화요일',
        3:'수요일',
        4:'목요일',
        5:'금요일',
        6:'토요일',
        7:'일요일',
    }.get(day '요일을 찾지 못했습니다')

switch(8) # 못 찾는 값을 넣었을 때 default 값을 줍니다 '요일을 찾지 못했습니다'

# keys
{'A': [10, 20], 'B': [20, 30], 'C': [30, 40]}.keys()

{'A': [10, 20], 'B': [20, 30], 'C': [30, 40]}.values()

{'A': [10, 20], 'B': [20, 30], 'C': [30, 40]}.items()

dict.fromkeys('hello')


dict.fromkeys('leehojun', 100)


d = {'one' : '하나', 'two' : '둘', 'three' : '셋'}
d.update({'one' : 1, 'two' : 2})
d
#거의 안쓰는 이유는 이렇게 하지 않고 값을 하나씩 넣는 방식을 많이 쓰기 때문이다.

##딕셔너리 순회

#key만 순회합니다.

d = {'two' : 2, 'three' : '셋'}
for i in d:
    print(i)

#value만 순회합니다
d = {'two' : 2, 'three' : '셋'}
for i in d:    
    print(d[i])

##언패킹
*많이 사용되니 기억하기

#패킹은 감싼다는 것 : 1,2,3 => [1,2,3]
#언패킹은 반대 : [1,2,3] => 1,2,3

a,b,c=10,20,30
a

for i,j in [[10,20],[30,40],[50,60]]:
    print(i,j)

for i,j,k in [[10,20,[1,2]],[30,40,[3,4]],[50,60,[5,6]]]:
    print(i,j,k)

for i,j,k in [[10,20,[1,2]],[30,40,[3,4]],[50,60,[5,6]]]:
    print(i,j,k)

#swap
a=10
b=15
a,b=b,a
a,b



a,b,c=(10,20,30)
a
#소괄호 대괄호 상관없이 위와 같이 똑같아요


for i , j in d.items():
     print(i, j)

d.items()

#max 를 이용한 dict최대 value의 key 값 가져오기

d={
    'test1':10,
    'test2':20,
    'test3':31,
    'test4':11,
}

# max(d.values()) ->value만 가져오는 것 
# max(d, key=lambda x:d[x])
max(d, key=d.get) #이걸 많이 사용함 

##set (집함)


-집합 자료형은 중복을 허용하지 않으며, 

-순서가 없는 자료형입니다. (팝쓰지마)

# 카운팅하거나 중복제거, 알고리즘 문제풀이 외에는 잘 풀지 않음

n = set([1, 1, 2, 2, 3, 3, 4])
print(n)

s =set('hello world')
print(s)

n = set([1, 1, 2, 2, 3, 3, 4])
n.add(1000)
print(n)

n = set([1, 1, 2, 2, 3, 3, 4])
n.update ({10,20})
print(n)

n = set([1, 1, 2, 2, 3, 3, 4])
n.remove (1)
print(n)

**이 pop은 실무에서 사용하지 않습니다. **
값을 랜덤하게 뽑아내기 때문입니다. 높은 확률로 앞에서부터 뽑아내긴 하지만 확률에 기대는 코딩을 하지 않기를 바랍니다. 공식문서에서는 랜덤하게 뽑아낸다고 되어 있습니다.

Remove and return an arbitrary element from the set. Raises KeyError if the set is empty.

#교집합 : 별 세개
a={1,2,3}
b={3,4,5}
a&b
a.intersection(b)

#합집함 
a={1,2,3}
b={3,4,5}
a|b
a.union(b)
#a+b = error : set은 더하기가 안돼요.

#차집합
a={1,2,3}
b={3,4,5}
a-b
a.difference(b)

#issubset
s = {1, 2, 3, 4}
ss = {3, 4, 5, 6}
s.issubset({1, 2})
s.issubset({1, 2, 3, 4, 5, 6,7,8}) #s가 {}이 속 친구들의 subset이야?

# https://school.programmers.co.kr/learn/courses/30/lessons/120903?language=python3
def solution(s1, s2):
    return len(set(s1) & set(s2))

# https://school.programmers.co.kr/learn/courses/30/lessons/120888
# my_string	result
# "people"	"peol"
# "We are the world"	"We arthwold"


def solution(my_string):
    return set(my_string)

solution('people')

def solution(my_string):
    return ''.join(set(my_string))

solution('people')

def solution(my_string):
    집합=set(my_string)
    result=''
    for i in my_string:
        if i in 집합:
            result += i
            집합.remove(i)
    return result

solution('people')

# {'e', 'l', 'o', 'p'}

result=''
for i in 'people':
    if i not in result:
        result += i

# def solution(my_string):
#     return ''.join(set(my_string))

result

##!!연습문제

# 연습문제 1
student_score = {
		'홍의': 97,
		'원희': 60,
		'동해': 77,
		'변수': 79,
		'창현': 89,
}

# - 학생들의 **총점**을 구하는 코드를 작성하세요.
# - 학생들의 **평균 점수**를 구하는 코드를 작성하세요.
# - 점수가 가장 **높은** 학생의 이름과 그 점수를 구하는 코드를 작성하세요.
# - 점수가 가장 **낮은** 학생의 이름과 그 점수를 구하는 코드를 작성하세요.

# - 학생들의 **총점**을 구하는 코드를 작성하세요.
student_score = {
		'홍의': 97,
		'원희': 60,
		'동해': 77,
		'변수': 79,
		'창현': 89,
}
print(f'학생들의 총점은 {sum(student_score.values())}입니다.')

# - 학생들의 **평균 점수**를 구하는 코드를 작성하세요.
average_score = sum(student_score.values())/len(student_score)
print(f'학생들의 평균 점수는{average_score}입니다.')

# - 점수가 가장 **높은** 학생의 이름과 그 점수를 구하는 코드를 작성하세요.
highest_student=max(student_score, key=student_score.get)
highest_score=student_score[highest_student]
print(highest_student,highest_score)



# - 점수가 가장 **낮은** 학생의 이름과 그 점수를 구하는 코드를 작성하세요.
lowest_name=min(student_score, key=student_score.get)
lowest_score=student_score[lowest_name]
print(lowest_name, lowest_score)

# 연습문제 2
# 학생들은 점심 메뉴를 고를 때, 한 명이라도 싫어하는 메뉴라면 고르지 않기로 했습니다. 
# 최종 후보 메뉴들의 리스트를 구하는 코드를 작성해주세요.

like = ['볶음밥', '라면', '국수', '파스타', '치킨', '짜장면', '국밥']
dislike = ['국밥', '짬뽕', '찜닭', '파스타', '국수', '카레', '덮밥']

like = ['볶음밥', '라면', '국수', '파스타', '치킨', '짜장면', '국밥']
dislike = ['국밥', '짬뽕', '찜닭', '파스타', '국수', '카레', '덮밥']

set(like)-set(dislike)
# print(like.intersection(dislike))
